{"prompt": "class OrderProcessor { public void processOrder(Order order) { order.getCustomer().getAddress().getCity(); } }", "completion": "Problema: A classe `OrderProcessor` est\u00c3\u00a1 violando a Lei de Demeter ao acessar diretamente o endere\u00c3\u00a7o e a cidade do cliente. Em vez disso, `Order` deveria fornecer um m\u00c3\u00a9todo como `getCustomerCity()` para evitar a chamada encadeada."}
{"prompt": "class Car { public void startEngine() { engine.getFuelPump().activate(); } }", "completion": "Problema: A classe `Car` est\u00c3\u00a1 violando a Lei de Demeter ao acessar o `FuelPump` atrav\u00c3\u00a9s de `engine`. O m\u00c3\u00a9todo `startEngine()` deveria encapsular esse comportamento dentro da pr\u00c3\u00b3pria classe `Engine`."}
{"prompt": "class Library { public void checkoutBook(Book book) { book.getLibraryCard().getHolder().getName(); } }", "completion": "Problema: A classe `Library` est\u00c3\u00a1 violando a Lei de Demeter ao acessar o nome do titular do cart\u00c3\u00a3o de biblioteca por meio de m\u00c3\u00baltiplas chamadas encadeadas. A classe `Book` ou `LibraryCard` deveria fornecer um m\u00c3\u00a9todo como `getCardHolderName()`."}
{"prompt": "class Flight { public void prepareForTakeoff() { cockpit.getPilot().getCredentials().validate(); } }", "completion": "Problema: A classe `Flight` est\u00c3\u00a1 violando a Lei de Demeter ao acessar as credenciais do piloto diretamente. `Cockpit` deveria fornecer um m\u00c3\u00a9todo para validar as credenciais do piloto sem expor sua estrutura interna."}
{"prompt": "class ShoppingCart { public void finalizePurchase() { customer.getPaymentInfo().getCreditCard().charge(); } }", "completion": "Problema: A classe `ShoppingCart` est\u00c3\u00a1 violando a Lei de Demeter ao acessar os detalhes do cart\u00c3\u00a3o de cr\u00c3\u00a9dito do cliente por meio de m\u00c3\u00baltiplas chamadas. A responsabilidade de cobrar o cart\u00c3\u00a3o deveria ser encapsulada em um m\u00c3\u00a9todo no objeto `PaymentInfo`."}
{"prompt": "class EmployeeManager { public void reviewEmployee(Employee employee) { employee.getDepartment().getManager().getContactInfo().sendMessage(); } }", "completion": "Problema: A classe `EmployeeManager` est\u00c3\u00a1 violando a Lei de Demeter ao acessar as informa\u00c3\u00a7\u00c3\u00b5es de contato do gerente por meio de v\u00c3\u00a1rias chamadas encadeadas. O acesso e envio da mensagem deveriam ser feitos por um m\u00c3\u00a9todo em `Department` ou `Manager`."}
{"prompt": "class House { public void openDoor() { securitySystem.getLock().getKey().unlock(); } }", "completion": "Problema: A classe `House` est\u00c3\u00a1 violando a Lei de Demeter ao acessar diretamente o cadeado e a chave do sistema de seguran\u00c3\u00a7a. O comportamento de destrancar deveria ser encapsulado em `SecuritySystem` ou `Lock`."}
{"prompt": "class Hotel { public void bookRoom() { guest.getReservation().getRoom().getDoor().unlock(); } }", "completion": "Problema: A classe `Hotel` est\u00c3\u00a1 violando a Lei de Demeter ao acessar diretamente a porta do quarto por meio de v\u00c3\u00a1rias chamadas. A classe `Reservation` ou `Room` deveria fornecer um m\u00c3\u00a9todo para desbloquear a porta."}
{"prompt": "class Company { public void processPayroll(Employee employee) { employee.getBankAccount().getBranch().getManager().approveTransaction(); } }", "completion": "Problema: A classe `Company` est\u00c3\u00a1 violando a Lei de Demeter ao acessar o gerente do banco por meio de v\u00c3\u00a1rias chamadas encadeadas. `BankAccount` ou `Branch` deveria encapsular esse comportamento."}
{"prompt": "class School { public void enrollStudent(Student student) { student.getParent().getContactInfo().getPhone().dial(); } }", "completion": "Problema: A classe `School` est\u00c3\u00a1 violando a Lei de Demeter ao acessar diretamente o telefone do pai do aluno por meio de v\u00c3\u00a1rias chamadas. `Parent` ou `ContactInfo` deveria fornecer um m\u00c3\u00a9todo para fazer a liga\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class UserService { private MySQLDatabase database = new MySQLDatabase(); public void saveUser(User user) { database.save(user); } }", "completion": "Problema: A classe `UserService` depende diretamente de uma implementa\u00c3\u00a7\u00c3\u00a3o concreta de `MySQLDatabase`, violando o DIP. Para resolver, `UserService` deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o (interface) como `Database`, e `MySQLDatabase` deveria implementar essa interface."}
{"prompt": "class PaymentProcessor { private StripePaymentGateway gateway = new StripePaymentGateway(); public void processPayment(double amount) { gateway.charge(amount); } }", "completion": "Problema: A classe `PaymentProcessor` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `StripePaymentGateway`, o que viola o DIP. O correto seria `PaymentProcessor` depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `PaymentGateway`, e `StripePaymentGateway` implementaria essa abstra\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class ReportGenerator { private PDFExporter exporter = new PDFExporter(); public void generateReport() { exporter.export(); } }", "completion": "Problema: A classe `ReportGenerator` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `PDFExporter`, violando o DIP. Ela deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `Exporter`, permitindo que diferentes exportadores sejam usados sem mudar a classe de alto n\u00c3\u00advel."}
{"prompt": "class NotificationService { private EmailSender emailSender = new EmailSender(); public void sendNotification(String message) { emailSender.send(message); } }", "completion": "Problema: A classe `NotificationService` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `EmailSender`, o que viola o DIP. O ideal seria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `NotificationSender` para permitir a troca entre diferentes m\u00c3\u00a9todos de envio."}
{"prompt": "class OrderProcessor { private ShippingService shippingService = new ShippingService(); public void processOrder(Order order) { shippingService.ship(order); } }", "completion": "Problema: A classe `OrderProcessor` depende diretamente de uma implementa\u00c3\u00a7\u00c3\u00a3o concreta `ShippingService`, violando o DIP. Ela deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `IShippingService`, e `ShippingService` deveria implement\u00c3\u00a1-la."}
{"prompt": "class DataAnalyzer { private CSVReader reader = new CSVReader(); public void analyze() { reader.read(); } }", "completion": "Problema: A classe `DataAnalyzer` depende diretamente de uma implementa\u00c3\u00a7\u00c3\u00a3o concreta `CSVReader`, o que viola o DIP. O correto seria a classe depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `FileReader`, e `CSVReader` seria uma das implementa\u00c3\u00a7\u00c3\u00b5es poss\u00c3\u00adveis."}
{"prompt": "class EmployeeManager { private SQLDatabase database = new SQLDatabase(); public void manageEmployee(Employee employee) { database.update(employee); } }", "completion": "Problema: A classe `EmployeeManager` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `SQLDatabase`, violando o DIP. Ela deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `Database`, permitindo que diferentes bancos de dados sejam usados sem alterar a l\u00c3\u00b3gica de alto n\u00c3\u00advel."}
{"prompt": "class WeatherService { private OpenWeatherMapAPI api = new OpenWeatherMapAPI(); public void fetchWeather(String location) { api.getWeather(location); } }", "completion": "Problema: A classe `WeatherService` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `OpenWeatherMapAPI`, violando o DIP. A classe deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `WeatherAPI`, permitindo o uso de diferentes APIs de clima sem modificar a l\u00c3\u00b3gica de alto n\u00c3\u00advel."}
{"prompt": "class FileBackup { private LocalFileStorage storage = new LocalFileStorage(); public void backup(String data) { storage.store(data); } }", "completion": "Problema: A classe `FileBackup` depende diretamente da implementa\u00c3\u00a7\u00c3\u00a3o concreta `LocalFileStorage`, violando o DIP. Ela deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `FileStorage`, e `LocalFileStorage` seria apenas uma implementa\u00c3\u00a7\u00c3\u00a3o dessa abstra\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class InvoiceGenerator { private HTMLRenderer renderer = new HTMLRenderer(); public void generateInvoice(Invoice invoice) { renderer.render(invoice); } }", "completion": "Problema: A classe `InvoiceGenerator` depende diretamente de uma implementa\u00c3\u00a7\u00c3\u00a3o concreta `HTMLRenderer`, violando o DIP. Ela deveria depender de uma abstra\u00c3\u00a7\u00c3\u00a3o como `Renderer`, permitindo o uso de diferentes renderizadores sem alterar a l\u00c3\u00b3gica de alto n\u00c3\u00advel."}
{"prompt": "interface Worker { void work(); void eat(); } class Robot implements Worker { public void work() { /* robot working */ } public void eat() { throw new UnsupportedOperationException(); /* robots don't eat */ } }", "completion": "Problema: A interface `Worker` viola o Princ\u00c3\u00adpio de Segrega\u00c3\u00a7\u00c3\u00a3o de Interface, pois a classe `Robot` \u00c3\u00a9 for\u00c3\u00a7ada a implementar o m\u00c3\u00a9todo `eat()`, que n\u00c3\u00a3o faz sentido para rob\u00c3\u00b4s. A interface deveria ser dividida em interfaces menores, como `Workable` e `Eatable`."}
{"prompt": "interface Document { void open(); void print(); void fax(); void scan(); } class PDFDocument implements Document { public void open() { /* logic */ } public void print() { /* logic */ } public void fax() { throw new UnsupportedOperationException(); } public void scan() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `Document` \u00c3\u00a9 muito grande e viola o ISP, pois a classe `PDFDocument` \u00c3\u00a9 for\u00c3\u00a7ada a implementar m\u00c3\u00a9todos como `fax()` e `scan()` que ela n\u00c3\u00a3o utiliza. A interface deveria ser dividida em v\u00c3\u00a1rias interfaces espec\u00c3\u00adficas, como `Printable`, `Scannable`, e `Faxable`."}
{"prompt": "interface Vehicle { void drive(); void fly(); } class Car implements Vehicle { public void drive() { /* logic */ } public void fly() { throw new UnsupportedOperationException(); /* cars don't fly */ } }", "completion": "Problema: A interface `Vehicle` viola o ISP, pois a classe `Car` n\u00c3\u00a3o deveria ser for\u00c3\u00a7ada a implementar o m\u00c3\u00a9todo `fly()`. O correto seria separar a interface em `Driveable` e `Flyable`."}
{"prompt": "interface PaymentProcessor { void processCreditCard(); void processPaypal(); void processBitcoin(); } class CreditCardProcessor implements PaymentProcessor { public void processCreditCard() { /* logic */ } public void processPaypal() { throw new UnsupportedOperationException(); } public void processBitcoin() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `PaymentProcessor` for\u00c3\u00a7a `CreditCardProcessor` a implementar m\u00c3\u00a9todos que n\u00c3\u00a3o s\u00c3\u00a3o relevantes, como `processPaypal()` e `processBitcoin()`. As interfaces deveriam ser segregadas em interfaces menores como `CreditCardPayment`, `PaypalPayment`, e `BitcoinPayment`."}
{"prompt": "interface Animal { void walk(); void fly(); void swim(); } class Dog implements Animal { public void walk() { /* logic */ } public void fly() { throw new UnsupportedOperationException(); } public void swim() { /* logic */ } }", "completion": "Problema: A interface `Animal` viola o ISP, pois a classe `Dog` \u00c3\u00a9 for\u00c3\u00a7ada a implementar `fly()`, o que n\u00c3\u00a3o faz sentido para c\u00c3\u00a3es. A interface deveria ser dividida em `Walkable`, `Flyable`, e `Swimmable`."}
{"prompt": "interface Appliance { void turnOn(); void turnOff(); void cook(); void clean(); } class Microwave implements Appliance { public void turnOn() { /* logic */ } public void turnOff() { /* logic */ } public void cook() { /* logic */ } public void clean() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `Appliance` \u00c3\u00a9 muito grande e viola o ISP, pois a classe `Microwave` n\u00c3\u00a3o utiliza o m\u00c3\u00a9todo `clean()`. A interface deveria ser dividida em interfaces menores e mais espec\u00c3\u00adficas, como `Cookable` e `Cleanable`."}
{"prompt": "interface RestaurantWorker { void cook(); void serve(); void clean(); } class Chef implements RestaurantWorker { public void cook() { /* logic */ } public void serve() { throw new UnsupportedOperationException(); } public void clean() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `RestaurantWorker` viola o ISP, pois a classe `Chef` n\u00c3\u00a3o deveria ser for\u00c3\u00a7ada a implementar m\u00c3\u00a9todos de `serve()` e `clean()`. A interface deveria ser dividida em `Cookable`, `Serveable`, e `Cleanable`."}
{"prompt": "interface BankService { void deposit(); void withdraw(); void invest(); void manageLoans(); } class BasicBankService implements BankService { public void deposit() { /* logic */ } public void withdraw() { /* logic */ } public void invest() { throw new UnsupportedOperationException(); } public void manageLoans() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `BankService` viola o ISP, pois a classe `BasicBankService` n\u00c3\u00a3o precisa implementar `invest()` e `manageLoans()`. Interfaces espec\u00c3\u00adficas como `InvestmentService` e `LoanService` seriam mais apropriadas."}
{"prompt": "interface ComputerPeripheral { void print(); void scan(); void fax(); } class Printer implements ComputerPeripheral { public void print() { /* logic */ } public void scan() { throw new UnsupportedOperationException(); } public void fax() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `ComputerPeripheral` for\u00c3\u00a7a `Printer` a implementar m\u00c3\u00a9todos irrelevantes como `scan()` e `fax()`, violando o ISP. As interfaces deveriam ser separadas em `Printable`, `Scannable`, e `Faxable`."}
{"prompt": "interface SmartDevice { void playMusic(); void turnOnLights(); void controlTemperature(); void makeCalls(); } class SmartSpeaker implements SmartDevice { public void playMusic() { /* logic */ } public void turnOnLights() { throw new UnsupportedOperationException(); } public void controlTemperature() { throw new UnsupportedOperationException(); } public void makeCalls() { throw new UnsupportedOperationException(); } }", "completion": "Problema: A interface `SmartDevice` \u00c3\u00a9 muito abrangente e for\u00c3\u00a7a `SmartSpeaker` a implementar m\u00c3\u00a9todos como `turnOnLights()` e `controlTemperature()`, que n\u00c3\u00a3o fazem sentido para um alto-falante inteligente. Interfaces mais espec\u00c3\u00adficas como `MusicPlayer`, `LightingController`, e `TemperatureController` seriam mais apropriadas."}
{"prompt": "class Bird { public void fly() { System.out.println(\"Flying\"); } } class Ostrich extends Bird { @Override public void fly() { throw new UnsupportedOperationException(\"Ostriches can't fly\"); } }", "completion": "Problema: A subclasse `Ostrich` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois ao substituir `Bird`, ela lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o quando o m\u00c3\u00a9todo `fly()` \u00c3\u00a9 chamado. Como a superclasse `Bird` espera que todos os p\u00c3\u00a1ssaros possam voar, isso quebra o contrato estabelecido. Recomenda-se ajustar o design para n\u00c3\u00a3o incluir `Ostrich` na hierarquia de classes que assume a habilidade de voar."}
{"prompt": "class Rectangle { public void setWidth(int width) { this.width = width; } public void setHeight(int height) { this.height = height; } } class Square extends Rectangle { @Override public void setWidth(int width) { this.width = width; this.height = width; } @Override public void setHeight(int height) { this.width = height; this.height = height; } }", "completion": "Problema: A subclasse `Square` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov. Ao substituir `Rectangle`, ela quebra a expectativa de que largura e altura possam ser ajustadas de maneira independente. Isso pode causar problemas em c\u00c3\u00b3digos que esperam o comportamento normal de `Rectangle`. Considere usar uma abordagem diferente para modelar quadrados e ret\u00c3\u00a2ngulos."}
{"prompt": "class Vehicle { public void startEngine() { System.out.println(\"Engine started\"); } } class Bicycle extends Vehicle { @Override public void startEngine() { throw new UnsupportedOperationException(\"Bicycles don't have engines\"); } }", "completion": "Problema: A subclasse `Bicycle` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov porque n\u00c3\u00a3o pode cumprir o contrato esperado de `Vehicle`, que assume que todos os ve\u00c3\u00adculos t\u00c3\u00aam motores. O uso de uma exce\u00c3\u00a7\u00c3\u00a3o quebra o comportamento esperado. Considere separar a hierarquia de classes para que bicicletas n\u00c3\u00a3o sejam tratadas como ve\u00c3\u00adculos motorizados."}
{"prompt": "class PaymentProcessor { public void processPayment(double amount) { System.out.println(\"Payment processed: \" + amount); } } class FreePlanPaymentProcessor extends PaymentProcessor { @Override public void processPayment(double amount) { if (amount > 0) { throw new UnsupportedOperationException(\"Free plans do not process payments\"); } } }", "completion": "Problema: A subclasse `FreePlanPaymentProcessor` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o se um pagamento for processado. Isso quebra o contrato esperado pela superclasse, que assume que todos os planos podem processar pagamentos. Uma solu\u00c3\u00a7\u00c3\u00a3o seria reestruturar o design para que planos gratuitos n\u00c3\u00a3o sejam tratados como processadores de pagamento."}
{"prompt": "class Employee { public double getBonus() { return baseSalary * 0.1; } } class Intern extends Employee { @Override public double getBonus() { throw new UnsupportedOperationException(\"Interns do not receive bonuses\"); } }", "completion": "Problema: A subclasse `Intern` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov ao lan\u00c3\u00a7ar uma exce\u00c3\u00a7\u00c3\u00a3o no m\u00c3\u00a9todo `getBonus()`. Isso quebra o contrato da classe `Employee`, que assume que todos os funcion\u00c3\u00a1rios podem receber um b\u00c3\u00b4nus. Considere tratar estagi\u00c3\u00a1rios de uma maneira diferente para evitar a viola\u00c3\u00a7\u00c3\u00a3o do LSP."}
{"prompt": "class Order { public void process() { System.out.println(\"Order processed\"); } } class PreOrder extends Order { @Override public void process() { throw new UnsupportedOperationException(\"Pre-orders cannot be processed yet\"); } }", "completion": "Problema: A subclasse `PreOrder` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov porque ela quebra o comportamento esperado de `Order`. O m\u00c3\u00a9todo `process()` da superclasse assume que todos os pedidos podem ser processados, o que n\u00c3\u00a3o \u00c3\u00a9 o caso para `PreOrder`. Recomenda-se criar uma abordagem separada para pedidos que ainda n\u00c3\u00a3o podem ser processados."}
{"prompt": "class Animal { public void makeSound() { System.out.println(\"Some generic sound\"); } } class MuteAnimal extends Animal { @Override public void makeSound() { throw new UnsupportedOperationException(\"This animal cannot make sound\"); } }", "completion": "Problema: A subclasse `MuteAnimal` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o quando o m\u00c3\u00a9todo `makeSound()` \u00c3\u00a9 chamado. A superclasse `Animal` espera que todos os animais possam fazer sons, o que n\u00c3\u00a3o \u00c3\u00a9 cumprido por `MuteAnimal`. Uma solu\u00c3\u00a7\u00c3\u00a3o seria modelar `MuteAnimal` de uma maneira diferente."}
{"prompt": "class Database { public void connect() { System.out.println(\"Connected to database\"); } } class ReadOnlyDatabase extends Database { @Override public void connect() { throw new UnsupportedOperationException(\"Cannot connect to read-only database\"); } }", "completion": "Problema: A subclasse `ReadOnlyDatabase` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois ela lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o no m\u00c3\u00a9todo `connect()`. Isso quebra o contrato da superclasse `Database`, que assume que todas as bases de dados podem ser conectadas. Recomenda-se redesenhar a hierarquia para separar bases de dados que podem e n\u00c3\u00a3o podem ser conectadas."}
{"prompt": "class File { public void write(String data) { System.out.println(\"Writing data to file\"); } } class ReadOnlyFile extends File { @Override public void write(String data) { throw new UnsupportedOperationException(\"Cannot write to read-only file\"); } }", "completion": "Problema: A subclasse `ReadOnlyFile` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o quando o m\u00c3\u00a9todo `write()` \u00c3\u00a9 chamado. Isso quebra o comportamento esperado da classe `File`. Considere redesenhar a hierarquia de classes para que arquivos somente leitura n\u00c3\u00a3o sejam tratados como arquivos normais."}
{"prompt": "class Vehicle { public void drive() { System.out.println(\"Driving the vehicle\"); } } class Boat extends Vehicle { @Override public void drive() { throw new UnsupportedOperationException(\"Boats do not drive on roads\"); } }", "completion": "Problema: A subclasse `Boat` viola o Princ\u00c3\u00adpio de Substitui\u00c3\u00a7\u00c3\u00a3o de Liskov, pois lan\u00c3\u00a7a uma exce\u00c3\u00a7\u00c3\u00a3o ao tentar dirigir o ve\u00c3\u00adculo. Isso quebra o contrato da superclasse `Vehicle`, que assume que todos os ve\u00c3\u00adculos podem ser dirigidos. Uma solu\u00c3\u00a7\u00c3\u00a3o seria criar uma hierarquia separada para ve\u00c3\u00adculos aqu\u00c3\u00a1ticos."}
{"prompt": "class ReportGenerator { public void generateReport(String type) { if (type.equals(\"PDF\")) { generatePDF(); } else if (type.equals(\"HTML\")) { generateHTML(); } } private void generatePDF() { /* logic */ } private void generateHTML() { /* logic */ } }", "completion": "Problema: Esta classe viola o princ\u00c3\u00adpio Open/Closed. Para adicionar novos tipos de relat\u00c3\u00b3rios, seria necess\u00c3\u00a1rio modificar o m\u00c3\u00a9todo `generateReport()`. Recomenda-se refatorar usando polimorfismo ou um padr\u00c3\u00a3o de projeto como Strategy, onde cada tipo de relat\u00c3\u00b3rio tem sua pr\u00c3\u00b3pria implementa\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "function calculateDiscount(customerType, amount) { if (customerType == 'Regular') { return amount * 0.1; } else if (customerType == 'VIP') { return amount * 0.2; } }", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o viola o princ\u00c3\u00adpio Open/Closed, pois, para adicionar novos tipos de clientes, ser\u00c3\u00a1 necess\u00c3\u00a1rio modificar a fun\u00c3\u00a7\u00c3\u00a3o `calculateDiscount()`. O ideal seria ter uma estrutura onde cada tipo de cliente possa definir seu pr\u00c3\u00b3prio desconto, como classes derivadas implementando uma interface comum."}
{"prompt": "class NotificationSender { public void sendNotification(String type) { if (type.equals(\"email\")) { sendEmail(); } else if (type.equals(\"sms\")) { sendSMS(); } } private void sendEmail() { /* logic */ } private void sendSMS() { /* logic */ } }", "completion": "Problema: A classe `NotificationSender` viola o princ\u00c3\u00adpio Open/Closed. Novos tipos de notifica\u00c3\u00a7\u00c3\u00b5es, como push notifications, exigiriam mudan\u00c3\u00a7as na l\u00c3\u00b3gica existente. O uso de polimorfismo ou do padr\u00c3\u00a3o Strategy permitiria adicionar novos tipos de notifica\u00c3\u00a7\u00c3\u00b5es sem modificar a classe principal."}
{"prompt": "public class Vehicle { public void start(String vehicleType) { if (vehicleType.equals(\"car\")) { startCar(); } else if (vehicleType.equals(\"bike\")) { startBike(); } } private void startCar() { /* logic */ } private void startBike() { /* logic */ } }", "completion": "Problema: A classe `Vehicle` viola o princ\u00c3\u00adpio Open/Closed, pois a adi\u00c3\u00a7\u00c3\u00a3o de novos tipos de ve\u00c3\u00adculos exigiria a modifica\u00c3\u00a7\u00c3\u00a3o do m\u00c3\u00a9todo `start()`. Uma abordagem melhor seria usar heran\u00c3\u00a7a e criar subclasses espec\u00c3\u00adficas para cada tipo de ve\u00c3\u00adculo."}
{"prompt": "def calculate_tax(country, amount): if country == 'USA': return amount * 0.07 elif country == 'Canada': return amount * 0.05", "completion": "Problema: Esta fun\u00c3\u00a7\u00c3\u00a3o viola o princ\u00c3\u00adpio Open/Closed, pois a adi\u00c3\u00a7\u00c3\u00a3o de novos pa\u00c3\u00adses exigiria modificar a fun\u00c3\u00a7\u00c3\u00a3o diretamente. Uma solu\u00c3\u00a7\u00c3\u00a3o melhor seria usar uma estrutura de classes espec\u00c3\u00adficas para cada pa\u00c3\u00ads ou um padr\u00c3\u00a3o de design que permita a extens\u00c3\u00a3o sem altera\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class ShapeDrawer { public void draw(String shapeType) { if (shapeType.equals(\"circle\")) { drawCircle(); } else if (shapeType.equals(\"square\")) { drawSquare(); } } private void drawCircle() { /* logic */ } private void drawSquare() { /* logic */ } }", "completion": "Problema: A classe `ShapeDrawer` viola o princ\u00c3\u00adpio Open/Closed. Para adicionar novas formas, seria necess\u00c3\u00a1rio modificar o m\u00c3\u00a9todo `draw()`. Recomenda-se usar polimorfismo com uma classe base `Shape` e subclasses espec\u00c3\u00adficas para cada tipo de forma."}
{"prompt": "def calculate_shipping(country, weight): if country == 'US': return weight * 5 elif country == 'UK': return weight * 6", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `calculate_shipping()` viola o princ\u00c3\u00adpio Open/Closed, pois a adi\u00c3\u00a7\u00c3\u00a3o de novos pa\u00c3\u00adses exigiria modifica\u00c3\u00a7\u00c3\u00a3o da l\u00c3\u00b3gica interna. \u00c3\u2030 prefer\u00c3\u00advel utilizar uma abordagem baseada em extensibilidade, como classes espec\u00c3\u00adficas para cada pa\u00c3\u00ads, ou um servi\u00c3\u00a7o de c\u00c3\u00a1lculo de frete que pode ser estendido."}
{"prompt": "class Logger { public void log(String level, String message) { if (level.equals(\"INFO\")) { logInfo(message); } else if (level.equals(\"ERROR\")) { logError(message); } } private void logInfo(String message) { /* logic */ } private void logError(String message) { /* logic */ } }", "completion": "Problema: A classe `Logger` viola o princ\u00c3\u00adpio Open/Closed. Novos n\u00c3\u00adveis de log, como `DEBUG`, exigiriam modifica\u00c3\u00a7\u00c3\u00b5es no m\u00c3\u00a9todo `log()`. O uso de polimorfismo ou um padr\u00c3\u00a3o de design como Strategy permitiria estender a funcionalidade sem modificar a classe original."}
{"prompt": "function calculateSalary(employeeType, hoursWorked) { if (employeeType == 'full-time') { return hoursWorked * 40; } else if (employeeType == 'part-time') { return hoursWorked * 20; } }", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `calculateSalary` viola o princ\u00c3\u00adpio Open/Closed, pois a adi\u00c3\u00a7\u00c3\u00a3o de novos tipos de funcion\u00c3\u00a1rios exigiria modificar a fun\u00c3\u00a7\u00c3\u00a3o existente. Uma abordagem melhor seria usar classes ou objetos espec\u00c3\u00adficos para cada tipo de funcion\u00c3\u00a1rio, cada um implementando sua pr\u00c3\u00b3pria l\u00c3\u00b3gica de c\u00c3\u00a1lculo salarial."}
{"prompt": "class PaymentProcessor { public void processPayment(String method) { if (method.equals(\"credit_card\")) { processCreditCard(); } else if (method.equals(\"paypal\")) { processPaypal(); } } private void processCreditCard() { /* logic */ } private void processPaypal() { /* logic */ } }", "completion": "Problema: A classe `PaymentProcessor` viola o princ\u00c3\u00adpio Open/Closed. Adicionar novos m\u00c3\u00a9todos de pagamento exigiria modificar o m\u00c3\u00a9todo `processPayment()`. Um design mais flex\u00c3\u00advel seria usar polimorfismo ou um padr\u00c3\u00a3o como Strategy para que cada m\u00c3\u00a9todo de pagamento tenha sua pr\u00c3\u00b3pria classe que implemente a interface de processamento."}
{"prompt": "class User { public void saveUserToDatabase() { /* salvar no banco de dados */ } public void validateUserInput() { /* validar entrada do usu\u00c3\u00a1rio */ } public void sendWelcomeEmail() { /* enviar e-mail de boas-vindas */ } }", "completion": "Problema: A classe `User` viola o Princ\u00c3\u00adpio da Responsabilidade \u00c3\u0161nica (SRP), pois est\u00c3\u00a1 lidando com a persist\u00c3\u00aancia no banco de dados, valida\u00c3\u00a7\u00c3\u00a3o de entrada e envio de e-mail. Essas responsabilidades devem ser separadas em classes distintas, como `UserRepository`, `UserValidator`, e `EmailService`."}
{"prompt": "class Order { public void calculateTotal() { /* calcular total */ } public void printInvoice() { /* imprimir fatura */ } public void saveToDatabase() { /* salvar no banco de dados */ } }", "completion": "Problema: A classe `Order` viola o SRP porque est\u00c3\u00a1 lidando com c\u00c3\u00a1lculos, impress\u00c3\u00a3o e persist\u00c3\u00aancia no banco de dados. Cada uma dessas responsabilidades deve ser delegada a classes diferentes, como `OrderCalculator`, `InvoicePrinter`, e `OrderRepository`."}
{"prompt": "class Report { public void generateReport() { /* gerar relat\u00c3\u00b3rio */ } public void formatReport() { /* formatar relat\u00c3\u00b3rio */ } public void exportToPDF() { /* exportar para PDF */ } }", "completion": "Problema: A classe `Report` est\u00c3\u00a1 violando o SRP, pois est\u00c3\u00a1 gerando, formatando e exportando relat\u00c3\u00b3rios. Essas responsabilidades devem ser separadas em classes espec\u00c3\u00adficas, como `ReportGenerator`, `ReportFormatter`, e `PDFExporter`."}
{"prompt": "class PaymentProcessor { public void processPayment() { /* processar pagamento */ } public void logTransaction() { /* registrar transa\u00c3\u00a7\u00c3\u00a3o */ } public void sendReceiptEmail() { /* enviar e-mail de recibo */ } }", "completion": "Problema: A classe `PaymentProcessor` viola o SRP ao lidar com o processamento de pagamentos, registro de transa\u00c3\u00a7\u00c3\u00b5es e envio de e-mails. Essas responsabilidades devem ser divididas em classes separadas, como `TransactionLogger` e `EmailService`."}
{"prompt": "class Product { public void calculateDiscount() { /* calcular desconto */ } public void saveProductToDatabase() { /* salvar no banco de dados */ } public void sendStockAlert() { /* enviar alerta de estoque */ } }", "completion": "Problema: A classe `Product` viola o SRP ao combinar l\u00c3\u00b3gica de neg\u00c3\u00b3cios (c\u00c3\u00a1lculo de desconto), persist\u00c3\u00aancia no banco de dados e envio de alertas. Cada uma dessas responsabilidades deve ser separada em classes como `DiscountCalculator`, `ProductRepository`, e `StockNotifier`."}
{"prompt": "class Notification { public void sendEmail(String message) { /* enviar e-mail */ } public void sendSMS(String message) { /* enviar SMS */ } public void logNotification(String message) { /* registrar notifica\u00c3\u00a7\u00c3\u00a3o */ } }", "completion": "Problema: A classe `Notification` viola o SRP ao combinar o envio de e-mails, envio de SMS e registro de notifica\u00c3\u00a7\u00c3\u00b5es. Essas responsabilidades devem ser divididas em classes distintas, como `EmailSender`, `SMSSender`, e `NotificationLogger`."}
{"prompt": "class Employee { public void calculateSalary() { /* calcular sal\u00c3\u00a1rio */ } public void generatePayslip() { /* gerar holerite */ } public void saveEmployeeData() { /* salvar dados do funcion\u00c3\u00a1rio */ } }", "completion": "Problema: A classe `Employee` viola o SRP ao lidar com o c\u00c3\u00a1lculo de sal\u00c3\u00a1rio, gera\u00c3\u00a7\u00c3\u00a3o de holerite e persist\u00c3\u00aancia de dados. Essas responsabilidades devem ser separadas em classes espec\u00c3\u00adficas, como `SalaryCalculator`, `PayslipGenerator`, e `EmployeeRepository`."}
{"prompt": "class ShoppingCart { public void addItem(Item item) { /* adicionar item */ } public void calculateTotal() { /* calcular total */ } public void sendOrderConfirmation() { /* enviar confirma\u00c3\u00a7\u00c3\u00a3o de pedido */ } }", "completion": "Problema: A classe `ShoppingCart` viola o SRP ao combinar a adi\u00c3\u00a7\u00c3\u00a3o de itens, c\u00c3\u00a1lculo de totais e envio de confirma\u00c3\u00a7\u00c3\u00b5es. Essas responsabilidades devem ser separadas em classes espec\u00c3\u00adficas, como `CartManager`, `TotalCalculator`, e `OrderConfirmationSender`."}
{"prompt": "class Logger { public void logToFile(String message) { /* registrar no arquivo */ } public void logToDatabase(String message) { /* registrar no banco de dados */ } public void logToConsole(String message) { /* registrar no console */ } }", "completion": "Problema: A classe `Logger` viola o SRP ao lidar com diferentes formas de registro (arquivo, banco de dados, console). Essas responsabilidades devem ser separadas em classes espec\u00c3\u00adficas como `FileLogger`, `DatabaseLogger`, e `ConsoleLogger`."}
{"prompt": "class Customer { public void createProfile() { /* criar perfil */ } public void updateProfile() { /* atualizar perfil */ } public void sendPromotionalEmail() { /* enviar e-mail promocional */ } }", "completion": "Problema: A classe `Customer` viola o SRP ao lidar com a cria\u00c3\u00a7\u00c3\u00a3o de perfil, atualiza\u00c3\u00a7\u00c3\u00a3o de perfil e envio de e-mails promocionais. Essas responsabilidades devem ser separadas em classes espec\u00c3\u00adficas, como `CustomerProfileManager` e `EmailMarketingService`."}
{"prompt": "class PayPal { public void makePayment(double amount) { /* PayPal payment logic */ } } class CreditCard { public void processPayment(double amount) { /* Credit card payment logic */ } }", "completion": "Problema: As classes `PayPal` e `CreditCard` executam a\u00c3\u00a7\u00c3\u00b5es semelhantes (processar pagamento), mas possuem interfaces diferentes (`makePayment()` e `processPayment()`). Isso cria inconsist\u00c3\u00aancia. Considere criar uma interface comum (ex.: `PaymentMethod`) para uniformizar o comportamento."}
{"prompt": "class XMLParser { public void parseXML(String data) { /* XML parsing logic */ } } class JSONParser { public void convertFromJSON(String data) { /* JSON parsing logic */ } }", "completion": "Problema: As classes `XMLParser` e `JSONParser` fazem o mesmo tipo de trabalho (parsing de dados), mas usam m\u00c3\u00a9todos com diferentes interfaces (`parseXML()` e `convertFromJSON()`). Uma interface comum de parsing melhoraria a consist\u00c3\u00aancia e a usabilidade."}
{"prompt": "class LocalFileStorage { public void saveToFile(String data) { /* Save data locally */ } } class CloudFileStorage { public void uploadFile(String data) { /* Upload data to the cloud */ } }", "completion": "Problema: Ambas as classes `LocalFileStorage` e `CloudFileStorage` executam opera\u00c3\u00a7\u00c3\u00b5es de armazenamento, mas suas interfaces diferem (`saveToFile()` e `uploadFile()`). Uma interface comum de armazenamento ajudaria a unificar as opera\u00c3\u00a7\u00c3\u00b5es."}
{"prompt": "class MySQLDatabase { public void connectToMySQL() { /* MySQL connection logic */ } } class PostgreSQLDatabase { public void establishPostgresConnection() { /* PostgreSQL connection logic */ } }", "completion": "Problema: As classes `MySQLDatabase` e `PostgreSQLDatabase` representam conex\u00c3\u00b5es de banco de dados, mas possuem interfaces diferentes (`connectToMySQL()` e `establishPostgresConnection()`). Isso cria inconsist\u00c3\u00aancia. Use uma interface comum para conex\u00c3\u00b5es de banco de dados."}
{"prompt": "class PDFExporter { public void exportAsPDF(String content) { /* Export as PDF */ } } class CSVExporter { public void exportToCSV(String content) { /* Export as CSV */ } }", "completion": "Problema: As classes `PDFExporter` e `CSVExporter` fazem exporta\u00c3\u00a7\u00c3\u00a3o de dados, mas suas interfaces diferem (`exportAsPDF()` e `exportToCSV()`). Uma interface comum de exporta\u00c3\u00a7\u00c3\u00a3o padronizaria o processo e simplificaria o c\u00c3\u00b3digo."}
{"prompt": "class OracleDatabase { public void queryOracle(String query) { /* Oracle query logic */ } } class MongoDBDatabase { public void runMongoQuery(String query) { /* MongoDB query logic */ } }", "completion": "Problema: Ambas as classes `OracleDatabase` e `MongoDBDatabase` executam consultas em bancos de dados, mas t\u00c3\u00aam diferentes interfaces (`queryOracle()` e `runMongoQuery()`). Usar uma interface comum para consultas de banco de dados aumentaria a coes\u00c3\u00a3o do c\u00c3\u00b3digo."}
{"prompt": "class EmailNotification { public void sendEmail(String message) { /* Email sending logic */ } } class SMSNotification { public void sendText(String message) { /* SMS sending logic */ } }", "completion": "Problema: As classes `EmailNotification` e `SMSNotification` enviam notifica\u00c3\u00a7\u00c3\u00b5es, mas t\u00c3\u00aam diferentes interfaces (`sendEmail()` e `sendText()`). Uma interface comum de notifica\u00c3\u00a7\u00c3\u00b5es melhoraria a consist\u00c3\u00aancia."}
{"prompt": "class AESFileEncryptor { public void encryptFile(String filePath) { /* AES encryption logic */ } } class RSAFileEncryptor { public void performRSAEncryption(String filePath) { /* RSA encryption logic */ } }", "completion": "Problema: Ambas as classes `AESFileEncryptor` e `RSAFileEncryptor` realizam criptografia de arquivos, mas possuem interfaces diferentes (`encryptFile()` e `performRSAEncryption()`). Usar uma interface comum para criptografia unificaria o processo."}
{"prompt": "class GoogleDriveUploader { public void uploadToGoogleDrive(String file) { /* Upload to Google Drive */ } } class DropboxUploader { public void uploadToDropbox(String file) { /* Upload to Dropbox */ } }", "completion": "Problema: As classes `GoogleDriveUploader` e `DropboxUploader` fazem upload de arquivos para diferentes servi\u00c3\u00a7os, mas usam interfaces distintas (`uploadToGoogleDrive()` e `uploadToDropbox()`). Considere uma interface comum para uploads de arquivos."}
{"prompt": "class PayPalPayment { public void handlePayPalPayment(double amount) { /* PayPal payment logic */ } } class StripePayment { public void manageStripePayment(double amount) { /* Stripe payment logic */ } }", "completion": "Problema: Ambas as classes `PayPalPayment` e `StripePayment` processam pagamentos, mas suas interfaces diferem (`handlePayPalPayment()` e `manageStripePayment()`). Uma interface comum para m\u00c3\u00a9todos de pagamento padronizaria o processo."}
{"prompt": "class User { // M\u00c3\u00a9todo que salva o usu\u00c3\u00a1rio no banco de dados public void saveUser() { /* l\u00c3\u00b3gica para salvar no banco de dados */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'M\u00c3\u00a9todo que salva o usu\u00c3\u00a1rio no banco de dados' \u00c3\u00a9 desnecess\u00c3\u00a1rio, pois o nome do m\u00c3\u00a9todo `saveUser()` j\u00c3\u00a1 deveria comunicar isso. Nomes de m\u00c3\u00a9todos e vari\u00c3\u00a1veis mais claros podem eliminar a necessidade de coment\u00c3\u00a1rios redundantes."}
{"prompt": "class Calculator { // M\u00c3\u00a9todo para adicionar dois n\u00c3\u00bameros public int add(int a, int b) { return a + b; } }", "completion": "Problema: O coment\u00c3\u00a1rio 'M\u00c3\u00a9todo para adicionar dois n\u00c3\u00bameros' \u00c3\u00a9 redundante. O nome do m\u00c3\u00a9todo `add()` j\u00c3\u00a1 descreve claramente sua fun\u00c3\u00a7\u00c3\u00a3o. Melhorar os nomes do m\u00c3\u00a9todo e evitar coment\u00c3\u00a1rios \u00c3\u00b3bvios pode simplificar o c\u00c3\u00b3digo."}
{"prompt": "class Order { // Calcula o total do pedido public double calculateTotal() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo */ return 0.0; } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Calcula o total do pedido' \u00c3\u00a9 redundante, pois o nome do m\u00c3\u00a9todo `calculateTotal()` j\u00c3\u00a1 descreve essa fun\u00c3\u00a7\u00c3\u00a3o. Um c\u00c3\u00b3digo bem nomeado elimina a necessidade de coment\u00c3\u00a1rios excessivos."}
{"prompt": "class ReportGenerator { // Gera o relat\u00c3\u00b3rio em formato PDF public void generatePDF() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de PDF */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Gera o relat\u00c3\u00b3rio em formato PDF' \u00c3\u00a9 desnecess\u00c3\u00a1rio, pois o nome do m\u00c3\u00a9todo `generatePDF()` j\u00c3\u00a1 comunica isso claramente. Coment\u00c3\u00a1rios redundantes podem ser eliminados com bons nomes de m\u00c3\u00a9todos."}
{"prompt": "class Payment { // Este m\u00c3\u00a9todo processa o pagamento public void processPayment() { /* l\u00c3\u00b3gica de processamento */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Este m\u00c3\u00a9todo processa o pagamento' \u00c3\u00a9 sup\u00c3\u00a9rfluo. O nome `processPayment()` j\u00c3\u00a1 descreve a fun\u00c3\u00a7\u00c3\u00a3o do m\u00c3\u00a9todo, tornando o coment\u00c3\u00a1rio desnecess\u00c3\u00a1rio. Um c\u00c3\u00b3digo claro deve ser autoexplicativo."}
{"prompt": "class Employee { // Calcula o b\u00c3\u00b4nus do funcion\u00c3\u00a1rio public double calculateBonus() { return 0.0; } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Calcula o b\u00c3\u00b4nus do funcion\u00c3\u00a1rio' \u00c3\u00a9 redundante. O m\u00c3\u00a9todo `calculateBonus()` j\u00c3\u00a1 comunica isso. Coment\u00c3\u00a1rios que explicam o \u00c3\u00b3bvio indicam que o c\u00c3\u00b3digo pode ser melhorado para ser mais leg\u00c3\u00advel sem coment\u00c3\u00a1rios."}
{"prompt": "class Vehicle { // Este m\u00c3\u00a9todo inicia o ve\u00c3\u00adculo public void start() { /* l\u00c3\u00b3gica de inicializa\u00c3\u00a7\u00c3\u00a3o */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Este m\u00c3\u00a9todo inicia o ve\u00c3\u00adculo' \u00c3\u00a9 desnecess\u00c3\u00a1rio, j\u00c3\u00a1 que o nome `start()` j\u00c3\u00a1 descreve claramente a fun\u00c3\u00a7\u00c3\u00a3o do m\u00c3\u00a9todo. O c\u00c3\u00b3digo deveria ser claro o suficiente para dispensar esse tipo de coment\u00c3\u00a1rio."}
{"prompt": "class ShoppingCart { // Adiciona um item ao carrinho de compras public void addItem(Item item) { /* l\u00c3\u00b3gica de adi\u00c3\u00a7\u00c3\u00a3o */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Adiciona um item ao carrinho de compras' \u00c3\u00a9 desnecess\u00c3\u00a1rio, pois o nome do m\u00c3\u00a9todo `addItem()` j\u00c3\u00a1 comunica essa inten\u00c3\u00a7\u00c3\u00a3o. Evitar coment\u00c3\u00a1rios que explicam o \u00c3\u00b3bvio melhora a legibilidade do c\u00c3\u00b3digo."}
{"prompt": "class Logger { // Este m\u00c3\u00a9todo grava a mensagem no arquivo public void logToFile(String message) { /* l\u00c3\u00b3gica de grava\u00c3\u00a7\u00c3\u00a3o */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Este m\u00c3\u00a9todo grava a mensagem no arquivo' \u00c3\u00a9 sup\u00c3\u00a9rfluo. O nome `logToFile()` j\u00c3\u00a1 descreve a fun\u00c3\u00a7\u00c3\u00a3o do m\u00c3\u00a9todo. Melhorar os nomes de m\u00c3\u00a9todos e vari\u00c3\u00a1veis pode eliminar a necessidade de coment\u00c3\u00a1rios triviais."}
{"prompt": "class DataParser { // Faz o parsing dos dados em JSON public void parseJSON(String data) { /* l\u00c3\u00b3gica de parsing */ } }", "completion": "Problema: O coment\u00c3\u00a1rio 'Faz o parsing dos dados em JSON' \u00c3\u00a9 desnecess\u00c3\u00a1rio, pois o nome do m\u00c3\u00a9todo `parseJSON()` j\u00c3\u00a1 comunica isso de forma clara. Coment\u00c3\u00a1rios redundantes podem ser eliminados com bons nomes de m\u00c3\u00a9todos e vari\u00c3\u00a1veis."}
{"prompt": "class User { private String name; private String email; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } }", "completion": "Problema: A classe `User` \u00c3\u00a9 uma Data Class que cont\u00c3\u00a9m apenas dados e m\u00c3\u00a9todos acessores. Para evitar esse code smell, a l\u00c3\u00b3gica associada ao usu\u00c3\u00a1rio, como valida\u00c3\u00a7\u00c3\u00a3o de e-mail ou manipula\u00c3\u00a7\u00c3\u00a3o de dados do usu\u00c3\u00a1rio, poderia ser adicionada \u00c3\u00a0 pr\u00c3\u00b3pria classe."}
{"prompt": "class Product { private String name; private double price; public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } }", "completion": "Problema: `Product` \u00c3\u00a9 uma Data Class com apenas getters e setters. O comportamento relacionado ao produto, como calcular descontos ou aplicar impostos, poderia ser movido para essa classe para torn\u00c3\u00a1-la mais rica em comportamento."}
{"prompt": "class Address { private String street; private String city; private String zipCode; public String getStreet() { return street; } public void setStreet(String street) { this.street = street; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getZipCode() { return zipCode; } public void setZipCode(String zipCode) { this.zipCode = zipCode; } }", "completion": "Problema: A classe `Address` \u00c3\u00a9 uma Data Class que apenas mant\u00c3\u00a9m dados. L\u00c3\u00b3gicas como valida\u00c3\u00a7\u00c3\u00a3o de CEP ou formata\u00c3\u00a7\u00c3\u00a3o de endere\u00c3\u00a7os poderiam ser inclu\u00c3\u00addas diretamente nessa classe para melhorar sua utilidade."}
{"prompt": "class Order { private int id; private String status; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } }", "completion": "Problema: A classe `Order` \u00c3\u00a9 uma Data Class. L\u00c3\u00b3gica como a atualiza\u00c3\u00a7\u00c3\u00a3o de status ou o c\u00c3\u00a1lculo de totais do pedido deveria ser movida para dentro da pr\u00c3\u00b3pria classe `Order`."}
{"prompt": "class Customer { private String firstName; private String lastName; public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } }", "completion": "Problema: A classe `Customer` \u00c3\u00a9 uma Data Class com apenas getters e setters. Comportamentos relacionados ao cliente, como a cria\u00c3\u00a7\u00c3\u00a3o de nome completo ou a valida\u00c3\u00a7\u00c3\u00a3o de dados, poderiam ser adicionados \u00c3\u00a0 classe."}
{"prompt": "class Book { private String title; private String author; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } }", "completion": "Problema: `Book` \u00c3\u00a9 uma Data Class. Funcionalidades relacionadas ao livro, como formata\u00c3\u00a7\u00c3\u00a3o de t\u00c3\u00adtulo ou c\u00c3\u00a1lculo de royalties, poderiam ser movidas para dentro da classe `Book`."}
{"prompt": "class BankAccount { private String accountNumber; private double balance; public String getAccountNumber() { return accountNumber; } public void setAccountNumber(String accountNumber) { this.accountNumber = accountNumber; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } }", "completion": "Problema: A classe `BankAccount` \u00c3\u00a9 uma Data Class com apenas getters e setters. L\u00c3\u00b3gicas como saques, dep\u00c3\u00b3sitos ou c\u00c3\u00a1lculo de juros deveriam ser movidas para essa classe, tornando-a mais \u00c3\u00batil e rica em comportamento."}
{"prompt": "class Invoice { private String number; private double amount; public String getNumber() { return number; } public void setNumber(String number) { this.number = number; } public double getAmount() { return amount; } public void setAmount(double amount) { this.amount = amount; } }", "completion": "Problema: A classe `Invoice` \u00c3\u00a9 uma Data Class. L\u00c3\u00b3gicas como a aplica\u00c3\u00a7\u00c3\u00a3o de impostos ou a verifica\u00c3\u00a7\u00c3\u00a3o de pagamento poderiam ser movidas para dentro da classe `Invoice`."}
{"prompt": "class Car { private String make; private String model; private int year; public String getMake() { return make; } public void setMake(String make) { this.make = make; } public String getModel() { return model; } public void setModel(String model) { this.model = model; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } }", "completion": "Problema: A classe `Car` \u00c3\u00a9 uma Data Class com apenas campos e m\u00c3\u00a9todos acessores. L\u00c3\u00b3gicas como c\u00c3\u00a1lculo de valor depreciado ou verifica\u00c3\u00a7\u00c3\u00a3o de quilometragem deveriam ser movidas para essa classe."}
{"prompt": "class Employee { private String id; private String department; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getDepartment() { return department; } public void setDepartment(String department) { this.department = department; } }", "completion": "Problema: A classe `Employee` \u00c3\u00a9 uma Data Class que cont\u00c3\u00a9m apenas dados e m\u00c3\u00a9todos acessores. L\u00c3\u00b3gicas como c\u00c3\u00a1lculo de sal\u00c3\u00a1rio ou troca de departamento deveriam ser movidas para essa classe."}
{"prompt": "class OrderProcessor { public void processOrder(String customerName, String customerAddress, String customerPhone, String productName, double productPrice) { /* l\u00c3\u00b3gica de processamento */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `customerName`, `customerAddress`, e `customerPhone` est\u00c3\u00a3o relacionados e aparecem juntos. Isso \u00c3\u00a9 um Data Clump e sugere que eles deveriam ser agrupados em uma classe `Customer`. O mesmo vale para `productName` e `productPrice`, que poderiam ser encapsulados em uma classe `Product`."}
{"prompt": "class ReportGenerator { public void generateReport(String title, String authorName, String authorEmail, int pageCount, String content) { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de relat\u00c3\u00b3rio */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `authorName` e `authorEmail` frequentemente aparecem juntos. Isso \u00c3\u00a9 um Data Clump e sugere que eles poderiam ser encapsulados em uma classe `Author`. Os par\u00c3\u00a2metros `title`, `pageCount` e `content` tamb\u00c3\u00a9m podem ser agrupados em uma classe `Report`."}
{"prompt": "class EventManager { public void createEvent(String eventName, String eventLocation, String eventDate, String eventTime) { /* l\u00c3\u00b3gica de cria\u00c3\u00a7\u00c3\u00a3o de evento */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `eventName`, `eventLocation`, `eventDate`, e `eventTime` est\u00c3\u00a3o relacionados e sempre aparecem juntos. Eles formam um Data Clump e devem ser encapsulados em uma classe `Event` para melhorar a coes\u00c3\u00a3o."}
{"prompt": "class PaymentService { public void processPayment(String cardNumber, String cardHolder, String expirationDate, String cvv, double amount) { /* l\u00c3\u00b3gica de processamento de pagamento */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `cardNumber`, `cardHolder`, `expirationDate`, e `cvv` est\u00c3\u00a3o relacionados e aparecem juntos. Isso \u00c3\u00a9 um Data Clump, e eles deveriam ser encapsulados em uma classe `CreditCard`."}
{"prompt": "class ReservationSystem { public void makeReservation(String guestName, String guestEmail, String guestPhone, String roomType, String checkInDate, String checkOutDate) { /* l\u00c3\u00b3gica de reserva */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `guestName`, `guestEmail`, e `guestPhone` est\u00c3\u00a3o relacionados e formam um Data Clump. Eles poderiam ser encapsulados em uma classe `Guest`. Da mesma forma, `roomType`, `checkInDate`, e `checkOutDate` poderiam ser agrupados em uma classe `Reservation`."}
{"prompt": "class InvoiceService { public void createInvoice(String customerName, String customerAddress, String itemDescription, int itemQuantity, double itemPrice) { /* l\u00c3\u00b3gica de cria\u00c3\u00a7\u00c3\u00a3o de fatura */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `customerName` e `customerAddress` formam um Data Clump e deveriam ser encapsulados em uma classe `Customer`. Da mesma forma, `itemDescription`, `itemQuantity`, e `itemPrice` poderiam ser encapsulados em uma classe `InvoiceItem`."}
{"prompt": "class EmployeeManager { public void addEmployee(String firstName, String lastName, String email, String department, double salary) { /* l\u00c3\u00b3gica de adi\u00c3\u00a7\u00c3\u00a3o de funcion\u00c3\u00a1rio */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `firstName`, `lastName`, e `email` formam um Data Clump e poderiam ser encapsulados em uma classe `Employee`. Da mesma forma, `department` e `salary` tamb\u00c3\u00a9m podem ser agrupados."}
{"prompt": "class WeatherService { public void reportWeather(String locationName, double latitude, double longitude, String weatherCondition, double temperature, double humidity) { /* l\u00c3\u00b3gica de relat\u00c3\u00b3rio de clima */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `locationName`, `latitude`, e `longitude` formam um Data Clump e poderiam ser encapsulados em uma classe `Location`. Da mesma forma, `weatherCondition`, `temperature`, e `humidity` podem ser agrupados em uma classe `WeatherReport`."}
{"prompt": "class ShipmentService { public void shipPackage(String senderName, String senderAddress, String recipientName, String recipientAddress, double weight, double cost) { /* l\u00c3\u00b3gica de envio de pacote */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `senderName` e `senderAddress`, assim como `recipientName` e `recipientAddress`, formam Data Clumps. Eles poderiam ser agrupados em classes `Sender` e `Recipient`. Da mesma forma, `weight` e `cost` podem ser encapsulados em uma classe `Package`."}
{"prompt": "class TravelAgency { public void bookFlight(String passengerName, String passengerEmail, String departureCity, String destinationCity, String flightDate, String flightTime) { /* l\u00c3\u00b3gica de reserva de voo */ } }", "completion": "Problema: Os par\u00c3\u00a2metros `passengerName` e `passengerEmail` formam um Data Clump e podem ser encapsulados em uma classe `Passenger`. Da mesma forma, `departureCity`, `destinationCity`, `flightDate`, e `flightTime` formam um conjunto de dados relacionados e podem ser encapsulados em uma classe `Flight`."}
{"prompt": "class User { public void login(String username, String password) { // C\u00c3\u00b3digo de login ativo } private void oldLoginMethod(String username) { // M\u00c3\u00a9todo obsoleto n\u00c3\u00a3o mais utilizado } }", "completion": "Problema: O m\u00c3\u00a9todo `oldLoginMethod` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois n\u00c3\u00a3o \u00c3\u00a9 mais utilizado ou chamado em lugar nenhum do sistema. Esse c\u00c3\u00b3digo aumenta a complexidade desnecess\u00c3\u00a1ria e deveria ser removido para melhorar a clareza e manuten\u00c3\u00a7\u00c3\u00a3o do c\u00c3\u00b3digo."}
{"prompt": "function calculate(a, b) { return a + b; } function oldCalculate(a, b) { return a * b; }", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `oldCalculate` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois n\u00c3\u00a3o \u00c3\u00a9 chamada em lugar algum no c\u00c3\u00b3digo e serve apenas para confundir. Recomenda-se remover essa fun\u00c3\u00a7\u00c3\u00a3o para evitar confus\u00c3\u00a3o e reduzir a complexidade."}
{"prompt": "class OrderProcessor { public void processOrder(Order order) { // C\u00c3\u00b3digo ativo } public void legacyProcessOrder(Order order) { // C\u00c3\u00b3digo legado n\u00c3\u00a3o mais utilizado } }", "completion": "Problema: O m\u00c3\u00a9todo `legacyProcessOrder` \u00c3\u00a9 c\u00c3\u00b3digo morto, j\u00c3\u00a1 que n\u00c3\u00a3o \u00c3\u00a9 chamado em nenhum lugar e foi substitu\u00c3\u00addo pelo m\u00c3\u00a9todo `processOrder`. Ele deveria ser removido para reduzir a complexidade do sistema."}
{"prompt": "def calculate_discount(price): if price > 100: return price * 0.1 else: return price * 0.05 def unused_function(): pass", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `unused_function()` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois nunca \u00c3\u00a9 chamada. Isso aumenta a complexidade e deve ser removido para melhorar a legibilidade e a manuten\u00c3\u00a7\u00c3\u00a3o do c\u00c3\u00b3digo."}
{"prompt": "public class Calculator { public int add(int a, int b) { return a + b; } private int subtract(int a, int b) { return a - b; } }", "completion": "Problema: O m\u00c3\u00a9todo `subtract` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois nunca \u00c3\u00a9 chamado em lugar nenhum do c\u00c3\u00b3digo. Para manter o c\u00c3\u00b3digo limpo e f\u00c3\u00a1cil de manter, ele deveria ser removido."}
{"prompt": "class Customer { public void updateProfile(String newProfileData) { // Atualiza\u00c3\u00a7\u00c3\u00a3o de perfil ativa } private void legacyUpdateProfile(String oldProfileData) { // C\u00c3\u00b3digo legado n\u00c3\u00a3o utilizado } }", "completion": "Problema: O m\u00c3\u00a9todo `legacyUpdateProfile` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois n\u00c3\u00a3o \u00c3\u00a9 mais utilizado. Deveria ser removido para reduzir a complexidade do c\u00c3\u00b3digo e facilitar a manuten\u00c3\u00a7\u00c3\u00a3o futura."}
{"prompt": "def fetch_data(): # Fun\u00c3\u00a7\u00c3\u00a3o ativa que busca dados return [] def unused_fetch_data(): # C\u00c3\u00b3digo legado que n\u00c3\u00a3o \u00c3\u00a9 mais utilizado return {}", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `unused_fetch_data()` \u00c3\u00a9 c\u00c3\u00b3digo morto, pois n\u00c3\u00a3o \u00c3\u00a9 chamada em nenhum lugar. Para melhorar a clareza do c\u00c3\u00b3digo e evitar confus\u00c3\u00b5es, ela deveria ser removida."}
{"prompt": "class Game { public void startGame() { // L\u00c3\u00b3gica ativa do jogo } public void debugGame() { // M\u00c3\u00a9todo de depura\u00c3\u00a7\u00c3\u00a3o n\u00c3\u00a3o mais usado } }", "completion": "Problema: O m\u00c3\u00a9todo `debugGame` \u00c3\u00a9 c\u00c3\u00b3digo morto, j\u00c3\u00a1 que n\u00c3\u00a3o \u00c3\u00a9 mais utilizado para depura\u00c3\u00a7\u00c3\u00a3o. Esse c\u00c3\u00b3digo deve ser removido para melhorar a clareza e reduzir a complexidade desnecess\u00c3\u00a1ria."}
{"prompt": "def process_order(order): # Fun\u00c3\u00a7\u00c3\u00a3o ativa para processar pedidos pass def legacy_process_order(order): # Fun\u00c3\u00a7\u00c3\u00a3o legada n\u00c3\u00a3o mais usada pass", "completion": "Problema: A fun\u00c3\u00a7\u00c3\u00a3o `legacy_process_order()` \u00c3\u00a9 c\u00c3\u00b3digo morto e deveria ser removida, pois n\u00c3\u00a3o \u00c3\u00a9 mais utilizada e apenas adiciona complexidade desnecess\u00c3\u00a1ria ao c\u00c3\u00b3digo."}
{"prompt": "class PaymentGateway { public void processPayment() { // M\u00c3\u00a9todo ativo de processamento de pagamento } private void legacyProcessPayment() { // C\u00c3\u00b3digo legado de processamento n\u00c3\u00a3o utilizado } }", "completion": "Problema: O m\u00c3\u00a9todo `legacyProcessPayment` \u00c3\u00a9 c\u00c3\u00b3digo morto, j\u00c3\u00a1 que n\u00c3\u00a3o \u00c3\u00a9 chamado em lugar algum no c\u00c3\u00b3digo. Ele deve ser removido para manter o c\u00c3\u00b3digo limpo e f\u00c3\u00a1cil de manter."}
{"prompt": "class User { public void saveToDatabase() { /* salvar no banco de dados */ } public void validateInput() { /* validar entrada do usu\u00c3\u00a1rio */ } public void sendWelcomeEmail() { /* enviar e-mail de boas-vindas */ } }", "completion": "Problema: A classe `User` sofre de Divergent Change, pois precisa ser modificada tanto para mudar a l\u00c3\u00b3gica de valida\u00c3\u00a7\u00c3\u00a3o, de persist\u00c3\u00aancia no banco de dados, quanto para envio de e-mails. Cada responsabilidade deveria ser extra\u00c3\u00adda para uma classe espec\u00c3\u00adfica, como `UserRepository`, `UserValidator`, e `EmailService`."}
{"prompt": "class Order { public void calculateTotal() { /* calcular o total do pedido */ } public void printInvoice() { /* imprimir fatura */ } public void saveToDatabase() { /* salvar no banco de dados */ } }", "completion": "Problema: A classe `Order` sofre de Divergent Change, pois deve ser alterada para modificar tanto a l\u00c3\u00b3gica de c\u00c3\u00a1lculo, de impress\u00c3\u00a3o, quanto de persist\u00c3\u00aancia. Essas responsabilidades deveriam ser extra\u00c3\u00addas para classes separadas como `OrderCalculator`, `InvoicePrinter`, e `OrderRepository`."}
{"prompt": "class Report { public void generate() { /* gerar relat\u00c3\u00b3rio */ } public void format() { /* formatar relat\u00c3\u00b3rio */ } public void exportToPDF() { /* exportar para PDF */ } }", "completion": "Problema: A classe `Report` precisa ser modificada por diferentes raz\u00c3\u00b5es: gera\u00c3\u00a7\u00c3\u00a3o, formata\u00c3\u00a7\u00c3\u00a3o e exporta\u00c3\u00a7\u00c3\u00a3o de relat\u00c3\u00b3rios. Isso caracteriza Divergent Change. Essas responsabilidades deveriam ser separadas em classes como `ReportGenerator`, `ReportFormatter`, e `PDFExporter`."}
{"prompt": "class Employee { public void calculateSalary() { /* calcular sal\u00c3\u00a1rio */ } public void updateDatabase() { /* atualizar banco de dados */ } public void sendPayroll() { /* enviar folha de pagamento */ } }", "completion": "Problema: A classe `Employee` sofre de Divergent Change, pois diferentes motivos podem exigir mudan\u00c3\u00a7as na classe: c\u00c3\u00a1lculo de sal\u00c3\u00a1rio, persist\u00c3\u00aancia e envio da folha de pagamento. Essas responsabilidades deveriam ser delegadas para classes separadas como `SalaryCalculator`, `EmployeeRepository`, e `PayrollService`."}
{"prompt": "class Product { public void updateStock() { /* atualizar estoque */ } public void calculateDiscount() { /* calcular desconto */ } public void updateDatabase() { /* salvar no banco de dados */ } }", "completion": "Problema: A classe `Product` precisa ser modificada por diferentes raz\u00c3\u00b5es, como gerenciamento de estoque, c\u00c3\u00a1lculo de desconto e persist\u00c3\u00aancia. Isso caracteriza Divergent Change, e essas responsabilidades deveriam ser extra\u00c3\u00addas para classes como `StockManager`, `DiscountCalculator`, e `ProductRepository`."}
{"prompt": "class PaymentProcessor { public void processPayment() { /* processar pagamento */ } public void logTransaction() { /* registrar transa\u00c3\u00a7\u00c3\u00a3o */ } public void sendReceipt() { /* enviar recibo */ } }", "completion": "Problema: A classe `PaymentProcessor` sofre de Divergent Change, pois \u00c3\u00a9 respons\u00c3\u00a1vel por processar pagamentos, registrar transa\u00c3\u00a7\u00c3\u00b5es e enviar recibos. Essas responsabilidades devem ser separadas em classes como `TransactionLogger`, `ReceiptSender`, e `PaymentHandler`."}
{"prompt": "class Customer { public void createProfile() { /* criar perfil */ } public void updateProfile() { /* atualizar perfil */ } public void sendPromotionalEmails() { /* enviar e-mails promocionais */ } }", "completion": "Problema: A classe `Customer` deve ser modificada por diferentes raz\u00c3\u00b5es: cria\u00c3\u00a7\u00c3\u00a3o de perfil, atualiza\u00c3\u00a7\u00c3\u00a3o de perfil e envio de e-mails promocionais. Isso caracteriza Divergent Change. Essas responsabilidades deveriam ser extra\u00c3\u00addas para classes como `ProfileManager` e `EmailMarketingService`."}
{"prompt": "class Account { public void deposit() { /* depositar */ } public void withdraw() { /* sacar */ } public void calculateInterest() { /* calcular juros */ } }", "completion": "Problema: A classe `Account` precisa ser alterada para modificar a l\u00c3\u00b3gica de dep\u00c3\u00b3sito, saque e c\u00c3\u00a1lculo de juros, caracterizando Divergent Change. Essas responsabilidades deveriam ser separadas em classes como `TransactionManager` e `InterestCalculator`."}
{"prompt": "class Invoice { public void generateInvoice() { /* gerar fatura */ } public void sendToCustomer() { /* enviar para o cliente */ } public void logInvoice() { /* registrar fatura */ } }", "completion": "Problema: A classe `Invoice` precisa ser modificada por diferentes raz\u00c3\u00b5es: gera\u00c3\u00a7\u00c3\u00a3o, envio e registro de faturas, o que caracteriza Divergent Change. Essas responsabilidades deveriam ser extra\u00c3\u00addas para classes como `InvoiceGenerator`, `InvoiceSender`, e `InvoiceLogger`."}
{"prompt": "class ShoppingCart { public void addItem(Item item) { /* adicionar item */ } public void calculateTotal() { /* calcular total */ } public void applyDiscount() { /* aplicar desconto */ } }", "completion": "Problema: A classe `ShoppingCart` precisa ser modificada por diferentes raz\u00c3\u00b5es: adicionar itens, calcular o total e aplicar descontos, o que caracteriza Divergent Change. Essas responsabilidades deveriam ser separadas em classes como `CartManager`, `TotalCalculator`, e `DiscountApplier`."}
{"prompt": "class OrderProcessor { public void processOnlineOrder(Order order) { double total = order.getPrice() * order.getQuantity(); sendConfirmationEmail(order); } public void processInStoreOrder(Order order) { double total = order.getPrice() * order.getQuantity(); sendConfirmationEmail(order); } }", "completion": "Problema: O c\u00c3\u00a1lculo do total e o envio do e-mail de confirma\u00c3\u00a7\u00c3\u00a3o s\u00c3\u00a3o duplicados em `processOnlineOrder()` e `processInStoreOrder()`. Esse c\u00c3\u00b3digo duplicado pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `calculateTotal()` e `sendConfirmation()`."}
{"prompt": "class UserService { public void createUser(User user) { if (user.getEmail() != null && user.getName() != null) { saveUser(user); } } public void updateUser(User user) { if (user.getEmail() != null && user.getName() != null) { saveUser(user); } } }", "completion": "Problema: A verifica\u00c3\u00a7\u00c3\u00a3o de `email` e `name` est\u00c3\u00a1 duplicada em `createUser()` e `updateUser()`. Esse c\u00c3\u00b3digo duplicado pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo de valida\u00c3\u00a7\u00c3\u00a3o compartilhado, como `validateUser()`."}
{"prompt": "class PaymentProcessor { public void processCreditCardPayment(double amount) { logTransaction(amount); sendReceipt(amount); } public void processPaypalPayment(double amount) { logTransaction(amount); sendReceipt(amount); } }", "completion": "Problema: `logTransaction()` e `sendReceipt()` s\u00c3\u00a3o duplicados em ambos os m\u00c3\u00a9todos de pagamento. Esse c\u00c3\u00b3digo duplicado pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo comum, como `processPayment()`."}
{"prompt": "class ReportGenerator { public void generatePdfReport(String content) { String header = \"Report Header\"; String footer = \"Report Footer\"; } public void generateHtmlReport(String content) { String header = \"Report Header\"; String footer = \"Report Footer\"; } }", "completion": "Problema: O c\u00c3\u00b3digo para `header` e `footer` est\u00c3\u00a1 duplicado em ambos os m\u00c3\u00a9todos de gera\u00c3\u00a7\u00c3\u00a3o de relat\u00c3\u00b3rios. Isso pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo comum, como `generateReportSkeleton()`."}
{"prompt": "class DiscountCalculator { public double calculateHolidayDiscount(Product product) { double discount = product.getPrice() * 0.1; return discount; } public double calculateSeasonalDiscount(Product product) { double discount = product.getPrice() * 0.1; return discount; } }", "completion": "Problema: O c\u00c3\u00a1lculo de desconto \u00c3\u00a9 duplicado nos m\u00c3\u00a9todos `calculateHolidayDiscount()` e `calculateSeasonalDiscount()`. Esse c\u00c3\u00b3digo pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `calculateDiscount()`."}
{"prompt": "class FileService { public void readFile(String filePath) { File file = new File(filePath); if (file.exists()) { // L\u00c3\u00aa o arquivo } } public void writeFile(String filePath, String content) { File file = new File(filePath); if (file.exists()) { // Escreve no arquivo } } }", "completion": "Problema: A verifica\u00c3\u00a7\u00c3\u00a3o `if (file.exists())` est\u00c3\u00a1 duplicada em `readFile()` e `writeFile()`. Esse c\u00c3\u00b3digo duplicado pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `checkFileExists()`."}
{"prompt": "class InvoiceService { public void generateInvoice() { String date = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()); System.out.println(date); } public void generateReceipt() { String date = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()); System.out.println(date); } }", "completion": "Problema: O formato da data e a impress\u00c3\u00a3o est\u00c3\u00a3o duplicados em `generateInvoice()` e `generateReceipt()`. Esse c\u00c3\u00b3digo pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `formatAndPrintDate()`."}
{"prompt": "class OrderService { public void placeOrder(Order order) { double shippingCost = calculateShipping(order); double tax = calculateTax(order); } public void processReturn(Order order) { double shippingCost = calculateShipping(order); double tax = calculateTax(order); } }", "completion": "Problema: O c\u00c3\u00a1lculo de `shippingCost` e `tax` est\u00c3\u00a1 duplicado em `placeOrder()` e `processReturn()`. Esse c\u00c3\u00b3digo duplicado pode ser extra\u00c3\u00addo para m\u00c3\u00a9todos compartilhados, como `applyCosts()`."}
{"prompt": "class EmailService { public void sendWelcomeEmail(User user) { String message = \"Welcome \" + user.getName(); System.out.println(message); } public void sendGoodbyeEmail(User user) { String message = \"Goodbye \" + user.getName(); System.out.println(message); } }", "completion": "Problema: A cria\u00c3\u00a7\u00c3\u00a3o da mensagem `message` est\u00c3\u00a1 duplicada em ambos os m\u00c3\u00a9todos. Esse c\u00c3\u00b3digo pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `createMessage()`."}
{"prompt": "class ShoppingCart { public void addItemToCart(Product product) { int stock = checkStock(product); if (stock > 0) { // Adiciona o produto ao carrinho } } public void removeItemFromCart(Product product) { int stock = checkStock(product); if (stock > 0) { // Remove o produto do carrinho } } }", "completion": "Problema: A verifica\u00c3\u00a7\u00c3\u00a3o de `checkStock(product)` est\u00c3\u00a1 duplicada em ambos os m\u00c3\u00a9todos. Esse c\u00c3\u00b3digo pode ser extra\u00c3\u00addo para um m\u00c3\u00a9todo compartilhado, como `verifyStockAndProceed()`."}
{"prompt": "class Invoice { public double calculateTotal(Customer customer) { return customer.getDiscountRate() * customer.getPreviousPurchases(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateTotal` na classe `Invoice` est\u00c3\u00a1 mais interessado nos dados da classe `Customer` (taxa de desconto e compras anteriores) do que nos dados da pr\u00c3\u00b3pria classe. Esse m\u00c3\u00a9todo provavelmente deveria ser movido para a classe `Customer`."}
{"prompt": "class Car { public double calculateFuelEfficiency(Engine engine) { return engine.getHorsePower() / engine.getFuelConsumption(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateFuelEfficiency` na classe `Car` est\u00c3\u00a1 mais interessado nos dados da classe `Engine` (pot\u00c3\u00aancia e consumo de combust\u00c3\u00advel). Esse m\u00c3\u00a9todo deveria ser movido para a classe `Engine`."}
{"prompt": "class EmployeeManager { public double calculateBonus(Employee employee) { return employee.getSalary() * employee.getPerformanceRating(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateBonus` na classe `EmployeeManager` est\u00c3\u00a1 focado nos dados da classe `Employee`. Ele deveria ser movido para a pr\u00c3\u00b3pria classe `Employee`, j\u00c3\u00a1 que essa l\u00c3\u00b3gica pertence ao empregado."}
{"prompt": "class OrderProcessor { public double calculateShippingCost(Order order) { return order.getWeight() * order.getDistance(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateShippingCost` na classe `OrderProcessor` depende fortemente dos dados da classe `Order` (peso e dist\u00c3\u00a2ncia). Esse m\u00c3\u00a9todo deveria estar na classe `Order` em vez de `OrderProcessor`."}
{"prompt": "class AccountService { public void transferMoney(Account from, Account to, double amount) { if (from.getBalance() >= amount) { from.debit(amount); to.credit(amount); } } }", "completion": "Problema: O m\u00c3\u00a9todo `transferMoney` na classe `AccountService` est\u00c3\u00a1 muito focado nos dados da classe `Account`. A l\u00c3\u00b3gica de transfer\u00c3\u00aancia provavelmente deveria estar na classe `Account`, encapsulando esse comportamento."}
{"prompt": "class ReportGenerator { public String generateReport(Order order) { return \"Total: \" + order.getTotal() + \", Date: \" + order.getDate(); } }", "completion": "Problema: O m\u00c3\u00a9todo `generateReport` na classe `ReportGenerator` est\u00c3\u00a1 focado demais nos dados da classe `Order`. Esse m\u00c3\u00a9todo deveria estar na pr\u00c3\u00b3pria classe `Order`, j\u00c3\u00a1 que \u00c3\u00a9 respons\u00c3\u00a1vel por expor seus dados."}
{"prompt": "class BankService { public double calculateInterest(Account account) { return account.getBalance() * account.getInterestRate(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateInterest` na classe `BankService` est\u00c3\u00a1 mais interessado nos dados da classe `Account`. A l\u00c3\u00b3gica de c\u00c3\u00a1lculo de juros deveria ser movida para a classe `Account`."}
{"prompt": "class VehicleService { public double calculateInsurance(Vehicle vehicle) { return vehicle.getAge() * vehicle.getValue() / 100; } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateInsurance` na classe `VehicleService` est\u00c3\u00a1 mais interessado nos dados da classe `Vehicle`. Esse comportamento provavelmente deveria ser movido para a classe `Vehicle`."}
{"prompt": "class ShoppingCart { public double calculateTotal(Product product) { return product.getPrice() * product.getQuantity(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateTotal` na classe `ShoppingCart` est\u00c3\u00a1 mais focado nos dados da classe `Product`. Esse comportamento deveria ser movido para a pr\u00c3\u00b3pria classe `Product`."}
{"prompt": "class ReservationSystem { public double calculateReservationCost(Room room) { return room.getRate() * room.getNumberOfNights(); } }", "completion": "Problema: O m\u00c3\u00a9todo `calculateReservationCost` na classe `ReservationSystem` est\u00c3\u00a1 focado nos dados da classe `Room`. Esse comportamento deveria estar na classe `Room`, onde os dados est\u00c3\u00a3o."}
{"prompt": "class OrderProcessor { public void processOrder(Order order) { order.getCustomer().setDiscount(10); } }", "completion": "Problema: `OrderProcessor` est\u00c3\u00a1 acessando e modificando o estado interno da classe `Customer` diretamente atrav\u00c3\u00a9s do m\u00c3\u00a9todo `setDiscount()`. Isso \u00c3\u00a9 um exemplo de Inappropriate Intimacy. A solu\u00c3\u00a7\u00c3\u00a3o seria fornecer um m\u00c3\u00a9todo no `Order` para aplicar descontos sem expor diretamente os detalhes internos da `Customer`."}
{"prompt": "class ReportGenerator { public void generateReport(Report report) { report.getHeader().setDate(new Date()); } }", "completion": "Problema: `ReportGenerator` est\u00c3\u00a1 modificando diretamente o estado interno da `Header` do `Report`. Isso quebra o encapsulamento e \u00c3\u00a9 um exemplo de Inappropriate Intimacy. A `Header` deveria ter m\u00c3\u00a9todos para definir a data sem permitir acesso direto aos seus atributos internos."}
{"prompt": "class EmployeeManager { public void adjustSalary(Employee employee, double adjustment) { employee.getSalaryDetails().setBaseSalary(employee.getSalaryDetails().getBaseSalary() + adjustment); } }", "completion": "Problema: `EmployeeManager` est\u00c3\u00a1 acessando e modificando diretamente os detalhes de sal\u00c3\u00a1rio atrav\u00c3\u00a9s de `SalaryDetails`. Isso demonstra Inappropriate Intimacy. Melhor seria fornecer um m\u00c3\u00a9todo em `Employee` para ajustar o sal\u00c3\u00a1rio sem expor os detalhes internos de `SalaryDetails`."}
{"prompt": "class BookStore { public void applyDiscount(Book book, double discount) { book.getPrice().setAmount(book.getPrice().getAmount() - discount); } }", "completion": "Problema: `BookStore` est\u00c3\u00a1 acessando diretamente o pre\u00c3\u00a7o do livro e ajustando-o, o que quebra o encapsulamento e \u00c3\u00a9 um exemplo de Inappropriate Intimacy. `Book` deveria ter um m\u00c3\u00a9todo para aplicar descontos sem expor diretamente os detalhes internos do pre\u00c3\u00a7o."}
{"prompt": "class NotificationService { public void sendNotification(Notification notification) { notification.getContent().setBody('New update available'); } }", "completion": "Problema: `NotificationService` est\u00c3\u00a1 modificando diretamente o conte\u00c3\u00bado do `Notification`. Isso \u00c3\u00a9 Inappropriate Intimacy. `Notification` deveria ter m\u00c3\u00a9todos para atualizar o conte\u00c3\u00bado sem expor diretamente seus detalhes internos."}
{"prompt": "class CarRepairShop { public void scheduleRepair(Car car, Date date) { car.getMaintenanceLog().addEntry(date, 'Scheduled repair'); } }", "completion": "Problema: `CarRepairShop` est\u00c3\u00a1 acessando diretamente o log de manuten\u00c3\u00a7\u00c3\u00a3o do `Car`. Isso quebra o encapsulamento e \u00c3\u00a9 um exemplo de Inappropriate Intimacy. O `Car` deveria ter m\u00c3\u00a9todos para agendar reparos e atualizar o log sem expor diretamente o `MaintenanceLog`."}
{"prompt": "class UserAccountManager { public void changeUserPassword(User user, String newPassword) { user.getPasswordManager().setPassword(newPassword); } }", "completion": "Problema: `UserAccountManager` est\u00c3\u00a1 acessando diretamente o `PasswordManager` do `User` e modificando a senha, o que demonstra Inappropriate Intimacy. O `User` deveria ter um m\u00c3\u00a9todo para alterar a senha sem expor diretamente o `PasswordManager`."}
{"prompt": "class Library { public void updateBookAvailability(Book book, boolean available) { book.getAvailabilityStatus().setAvailable(available); } }", "completion": "Problema: `Library` est\u00c3\u00a1 acessando diretamente o status de disponibilidade do `Book`. Isso quebra o encapsulamento e \u00c3\u00a9 um exemplo de Inappropriate Intimacy. `Book` deveria ter m\u00c3\u00a9todos para atualizar a disponibilidade sem expor diretamente o `AvailabilityStatus`."}
{"prompt": "class PaymentService { public void processPayment(Payment payment) { payment.getTransaction().setStatus('Processed'); } }", "completion": "Problema: `PaymentService` est\u00c3\u00a1 acessando diretamente a transa\u00c3\u00a7\u00c3\u00a3o do `Payment` e modificando seu status. Isso \u00c3\u00a9 Inappropriate Intimacy. `Payment` deveria ter um m\u00c3\u00a9todo para processar pagamentos e atualizar o status sem expor diretamente o `Transaction`."}
{"prompt": "class EventManager { public void setEventDate(Event event, Date date) { event.getEventDetails().setDate(date); } }", "completion": "Problema: `EventManager` est\u00c3\u00a1 acessando diretamente os detalhes do evento e modificando a data. Isso demonstra Inappropriate Intimacy. O `Event` deveria ter m\u00c3\u00a9todos para definir a data sem expor diretamente os detalhes internos."}
{"prompt": "class UserAccount { private String username; private String password; private String email; private String address; private String phoneNumber; public void login() { /* l\u00c3\u00b3gica de login */ } public void logout() { /* l\u00c3\u00b3gica de logout */ } public void updateProfile() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de perfil */ } public void sendEmailNotification() { /* l\u00c3\u00b3gica de envio de e-mail */ } public void changePassword() { /* l\u00c3\u00b3gica de mudan\u00c3\u00a7a de senha */ } public void validateAddress() { /* l\u00c3\u00b3gica de valida\u00c3\u00a7\u00c3\u00a3o de endere\u00c3\u00a7o */ } }", "completion": "Problema: A classe `UserAccount` \u00c3\u00a9 uma Large Class, pois gerencia login, logout, atualiza\u00c3\u00a7\u00c3\u00a3o de perfil, envio de e-mails, valida\u00c3\u00a7\u00c3\u00a3o de endere\u00c3\u00a7o e mudan\u00c3\u00a7as de senha. Essa classe poderia ser dividida em classes menores, como `AuthenticationService`, `ProfileService` e `NotificationService`."}
{"prompt": "class OrderManager { private List<Order> orders; public void createOrder() { /* l\u00c3\u00b3gica de cria\u00c3\u00a7\u00c3\u00a3o de pedido */ } public void updateOrder() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de pedido */ } public void calculateTotal() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo de total */ } public void applyDiscount() { /* l\u00c3\u00b3gica de aplica\u00c3\u00a7\u00c3\u00a3o de desconto */ } public void generateInvoice() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de fatura */ } public void sendOrderConfirmation() { /* l\u00c3\u00b3gica de envio de confirma\u00c3\u00a7\u00c3\u00a3o de pedido */ } }", "completion": "Problema: A classe `OrderManager` \u00c3\u00a9 uma Large Class que realiza m\u00c3\u00baltiplas responsabilidades, como cria\u00c3\u00a7\u00c3\u00a3o de pedidos, c\u00c3\u00a1lculo de totais, gera\u00c3\u00a7\u00c3\u00a3o de faturas e envio de confirma\u00c3\u00a7\u00c3\u00b5es. Ela poderia ser refatorada em classes menores, como `OrderService`, `InvoiceService`, e `DiscountService`."}
{"prompt": "class ShoppingCart { private List<Item> items; private double totalPrice; public void addItem() { /* l\u00c3\u00b3gica de adi\u00c3\u00a7\u00c3\u00a3o de item */ } public void removeItem() { /* l\u00c3\u00b3gica de remo\u00c3\u00a7\u00c3\u00a3o de item */ } public void calculateTotal() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo de total */ } public void applyCoupon() { /* l\u00c3\u00b3gica de aplica\u00c3\u00a7\u00c3\u00a3o de cupom */ } public void checkout() { /* l\u00c3\u00b3gica de finaliza\u00c3\u00a7\u00c3\u00a3o de compra */ } public void updateInventory() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de estoque */ } }", "completion": "Problema: A classe `ShoppingCart` \u00c3\u00a9 uma Large Class que gerencia itens, c\u00c3\u00a1lculos, cupons, checkout e estoque. Ela poderia ser dividida em classes como `CartManager`, `PricingService`, e `InventoryService`."}
{"prompt": "class BankAccount { private double balance; private List<Transaction> transactions; public void deposit() { /* l\u00c3\u00b3gica de dep\u00c3\u00b3sito */ } public void withdraw() { /* l\u00c3\u00b3gica de saque */ } public void generateStatement() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de extrato */ } public void calculateInterest() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo de juros */ } public void notifyAccountHolder() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o do titular da conta */ } }", "completion": "Problema: A classe `BankAccount` \u00c3\u00a9 uma Large Class que lida com dep\u00c3\u00b3sito, saque, extratos, juros e notifica\u00c3\u00a7\u00c3\u00b5es. Ela poderia ser dividida em classes menores, como `TransactionService`, `InterestCalculator`, e `NotificationService`."}
{"prompt": "class EmployeeManager { private List<Employee> employees; public void addEmployee() { /* l\u00c3\u00b3gica de adi\u00c3\u00a7\u00c3\u00a3o de funcion\u00c3\u00a1rio */ } public void removeEmployee() { /* l\u00c3\u00b3gica de remo\u00c3\u00a7\u00c3\u00a3o de funcion\u00c3\u00a1rio */ } public void calculatePayroll() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo de folha de pagamento */ } public void generateReports() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de relat\u00c3\u00b3rios */ } public void trackAttendance() { /* l\u00c3\u00b3gica de rastreamento de presen\u00c3\u00a7a */ } }", "completion": "Problema: A classe `EmployeeManager` \u00c3\u00a9 uma Large Class com responsabilidades diversas, como gerenciamento de funcion\u00c3\u00a1rios, folha de pagamento, relat\u00c3\u00b3rios e presen\u00c3\u00a7a. Isso poderia ser refatorado em classes como `PayrollService`, `AttendanceTracker`, e `EmployeeReportGenerator`."}
{"prompt": "class Vehicle { private String make; private String model; private int year; private double fuelLevel; private int mileage; public void startEngine() { /* l\u00c3\u00b3gica de partida */ } public void stopEngine() { /* l\u00c3\u00b3gica de parada */ } public void refuel() { /* l\u00c3\u00b3gica de reabastecimento */ } public void performMaintenance() { /* l\u00c3\u00b3gica de manuten\u00c3\u00a7\u00c3\u00a3o */ } public void calculateFuelEfficiency() { /* l\u00c3\u00b3gica de c\u00c3\u00a1lculo de efici\u00c3\u00aancia de combust\u00c3\u00advel */ } }", "completion": "Problema: A classe `Vehicle` \u00c3\u00a9 uma Large Class que lida com v\u00c3\u00a1rias responsabilidades, como gerenciamento de combust\u00c3\u00advel, manuten\u00c3\u00a7\u00c3\u00a3o e efici\u00c3\u00aancia. Ela poderia ser refatorada em classes menores, como `FuelManager`, `MaintenanceService`, e `EfficiencyCalculator`."}
{"prompt": "class HotelBookingSystem { private List<Room> rooms; private List<Reservation> reservations; public void checkRoomAvailability() { /* l\u00c3\u00b3gica de verifica\u00c3\u00a7\u00c3\u00a3o de disponibilidade de quarto */ } public void makeReservation() { /* l\u00c3\u00b3gica de cria\u00c3\u00a7\u00c3\u00a3o de reserva */ } public void cancelReservation() { /* l\u00c3\u00b3gica de cancelamento de reserva */ } public void processPayment() { /* l\u00c3\u00b3gica de processamento de pagamento */ } public void generateInvoice() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de fatura */ } public void sendConfirmationEmail() { /* l\u00c3\u00b3gica de envio de e-mail de confirma\u00c3\u00a7\u00c3\u00a3o */ } }", "completion": "Problema: A classe `HotelBookingSystem` \u00c3\u00a9 uma Large Class que faz muitas coisas, como gerenciar quartos, reservas, pagamentos e e-mails. Isso poderia ser dividido em v\u00c3\u00a1rias classes, como `RoomManager`, `ReservationService`, `PaymentProcessor`, e `NotificationService`."}
{"prompt": "class FlightBooking { private List<Flight> flights; private List<Ticket> tickets; public void searchFlights() { /* l\u00c3\u00b3gica de busca de voos */ } public void bookTicket() { /* l\u00c3\u00b3gica de reserva de bilhete */ } public void cancelTicket() { /* l\u00c3\u00b3gica de cancelamento de bilhete */ } public void generateTicket() { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de bilhete */ } public void processRefund() { /* l\u00c3\u00b3gica de processamento de reembolso */ } }", "completion": "Problema: A classe `FlightBooking` \u00c3\u00a9 uma Large Class que lida com busca de voos, reservas, cancelamentos e reembolsos. Ela poderia ser dividida em classes menores, como `FlightService`, `TicketingService`, e `RefundProcessor`."}
{"prompt": "class GameEngine { private List<Player> players; private List<Level> levels; public void startGame() { /* l\u00c3\u00b3gica de in\u00c3\u00adcio do jogo */ } public void endGame() { /* l\u00c3\u00b3gica de fim do jogo */ } public void updateScores() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de pontua\u00c3\u00a7\u00c3\u00b5es */ } public void renderGraphics() { /* l\u00c3\u00b3gica de renderiza\u00c3\u00a7\u00c3\u00a3o de gr\u00c3\u00a1ficos */ } public void manageAudio() { /* l\u00c3\u00b3gica de gerenciamento de \u00c3\u00a1udio */ } }", "completion": "Problema: A classe `GameEngine` \u00c3\u00a9 uma Large Class que gerencia muitos aspectos do jogo, como jogadores, n\u00c3\u00adveis, pontua\u00c3\u00a7\u00c3\u00b5es, gr\u00c3\u00a1ficos e \u00c3\u00a1udio. Ela poderia ser refatorada em classes espec\u00c3\u00adficas, como `ScoreManager`, `GraphicsEngine`, e `AudioManager`."}
{"prompt": "class EcommercePlatform { private List<Product> products; private List<Order> orders; private List<Customer> customers; public void browseProducts() { /* l\u00c3\u00b3gica de navega\u00c3\u00a7\u00c3\u00a3o de produtos */ } public void placeOrder() { /* l\u00c3\u00b3gica de coloca\u00c3\u00a7\u00c3\u00a3o de pedido */ } public void processPayment() { /* l\u00c3\u00b3gica de processamento de pagamento */ } public void trackShipment() { /* l\u00c3\u00b3gica de rastreamento de envio */ } public void handleReturns() { /* l\u00c3\u00b3gica de devolu\u00c3\u00a7\u00c3\u00b5es */ } public void sendPromotionalEmails() { /* l\u00c3\u00b3gica de envio de e-mails promocionais */ } }", "completion": "Problema: A classe `EcommercePlatform` \u00c3\u00a9 uma Large Class que lida com produtos, pedidos, pagamentos, rastreamento e marketing. Ela pode ser dividida em classes como `ProductCatalog`, `OrderService`, `PaymentProcessor`, `ShippingTracker`, e `MarketingService`."}
{"prompt": "class UserValidator { public boolean isValid(User user) { return user.getName() != null && user.getEmail() != null; } }", "completion": "Problema: `UserValidator` \u00c3\u00a9 uma Lazy Class com apenas um m\u00c3\u00a9todo simples. Essa l\u00c3\u00b3gica poderia ser movida para a pr\u00c3\u00b3pria classe `User`, eliminando a necessidade de uma classe separada."}
{"prompt": "class EmailSender { public void sendEmail(String email, String message) { // Envia e-mail } }", "completion": "Problema: `EmailSender` \u00c3\u00a9 uma Lazy Class com um \u00c3\u00banico m\u00c3\u00a9todo que pode ser combinado com outra classe, como `NotificationService`, que j\u00c3\u00a1 lida com notifica\u00c3\u00a7\u00c3\u00b5es de e-mail."}
{"prompt": "class DatabaseConnector { public void connect() { // Conecta ao banco de dados } }", "completion": "Problema: `DatabaseConnector` \u00c3\u00a9 uma Lazy Class com uma responsabilidade m\u00c3\u00adnima. Esse m\u00c3\u00a9todo poderia ser movido para uma classe `Database` maior, que lida com todas as opera\u00c3\u00a7\u00c3\u00b5es de banco de dados."}
{"prompt": "class DiscountCalculator { public double calculateDiscount(double price) { return price * 0.1; } }", "completion": "Problema: `DiscountCalculator` \u00c3\u00a9 uma Lazy Class com uma l\u00c3\u00b3gica simples de desconto. Esse m\u00c3\u00a9todo poderia ser movido para a classe `Product` ou `Order`, onde o desconto \u00c3\u00a9 realmente aplicado."}
{"prompt": "class Logger { public void log(String message) { System.out.println(message); } }", "completion": "Problema: `Logger` \u00c3\u00a9 uma Lazy Class com um \u00c3\u00banico m\u00c3\u00a9todo b\u00c3\u00a1sico. Essa funcionalidade de registro poderia ser movida para uma classe existente que lida com opera\u00c3\u00a7\u00c3\u00b5es de sistema, eliminando a necessidade de uma classe separada."}
{"prompt": "class PasswordHasher { public String hashPassword(String password) { return password.hashCode(); } }", "completion": "Problema: `PasswordHasher` \u00c3\u00a9 uma Lazy Class com um \u00c3\u00banico m\u00c3\u00a9todo de hash. Esse m\u00c3\u00a9todo poderia ser movido para a pr\u00c3\u00b3pria classe `User` ou `AuthenticationService`."}
{"prompt": "class OrderPrinter { public void print(Order order) { System.out.println(order.toString()); } }", "completion": "Problema: `OrderPrinter` \u00c3\u00a9 uma Lazy Class com uma fun\u00c3\u00a7\u00c3\u00a3o muito simples de imprimir. Esse m\u00c3\u00a9todo poderia ser movido para a classe `Order` ou para um servi\u00c3\u00a7o maior, como `OrderService`."}
{"prompt": "class CurrencyConverter { public double convert(double amount, String currency) { return amount * 1.1; } }", "completion": "Problema: `CurrencyConverter` \u00c3\u00a9 uma Lazy Class com uma \u00c3\u00banica fun\u00c3\u00a7\u00c3\u00a3o de convers\u00c3\u00a3o. Esse m\u00c3\u00a9todo poderia ser incorporado em uma classe financeira maior, como `TransactionService`."}
{"prompt": "class DateFormatter { public String format(Date date) { return date.toString(); } }", "completion": "Problema: `DateFormatter` \u00c3\u00a9 uma Lazy Class com uma \u00c3\u00banica fun\u00c3\u00a7\u00c3\u00a3o de formata\u00c3\u00a7\u00c3\u00a3o. Isso poderia ser movido para um utilit\u00c3\u00a1rio de data ou ser diretamente utilizado onde necess\u00c3\u00a1rio, eliminando a classe separada."}
{"prompt": "class FileDeleter { public void deleteFile(String filePath) { new File(filePath).delete(); } }", "completion": "Problema: `FileDeleter` \u00c3\u00a9 uma Lazy Class com um \u00c3\u00banico m\u00c3\u00a9todo de exclus\u00c3\u00a3o de arquivos. Isso poderia ser movido para um servi\u00c3\u00a7o maior de manipula\u00c3\u00a7\u00c3\u00a3o de arquivos, como `FileManager`."}
{"prompt": "class ReportGenerator { public void generateReport() { // Gera cabe\u00c3\u00a7alho // Gera corpo do relat\u00c3\u00b3rio // Calcula estat\u00c3\u00adsticas // Formata dados // Exporta para PDF } }", "completion": "Problema: O m\u00c3\u00a9todo `generateReport()` est\u00c3\u00a1 fazendo muitas coisas: gerando cabe\u00c3\u00a7alhos, corpo, calculando estat\u00c3\u00adsticas, formatando dados e exportando para PDF. Esse \u00c3\u00a9 um exemplo de Long Method. Cada uma dessas responsabilidades deveria ser extra\u00c3\u00adda para m\u00c3\u00a9todos menores, como `generateHeader()`, `generateBody()`, `calculateStatistics()`, etc."}
{"prompt": "class OrderProcessor { public void processOrder(Order order) { // Verifica estoque // Calcula desconto // Processa pagamento // Gera fatura // Envia notifica\u00c3\u00a7\u00c3\u00a3o } }", "completion": "Problema: O m\u00c3\u00a9todo `processOrder()` realiza muitas tarefas diferentes. Esse \u00c3\u00a9 um Long Method que deveria ser refatorado em m\u00c3\u00a9todos menores e espec\u00c3\u00adficos, como `checkStock()`, `calculateDiscount()`, `processPayment()`, etc."}
{"prompt": "class ShoppingCart { public void checkout() { // Valida o carrinho // Calcula o total // Processa o pagamento // Atualiza o estoque // Envia e-mail de confirma\u00c3\u00a7\u00c3\u00a3o } }", "completion": "Problema: O m\u00c3\u00a9todo `checkout()` faz v\u00c3\u00a1rias coisas: valida\u00c3\u00a7\u00c3\u00a3o, c\u00c3\u00a1lculo, processamento, atualiza\u00c3\u00a7\u00c3\u00a3o e envio de e-mail. Esse Long Method deveria ser dividido em m\u00c3\u00a9todos menores, como `validateCart()`, `calculateTotal()`, `processPayment()`, etc."}
{"prompt": "class InvoiceService { public void generateInvoice(Order order) { // Gera n\u00c3\u00bamero da fatura // Calcula impostos // Aplica descontos // Gera PDF da fatura // Armazena fatura no banco de dados } }", "completion": "Problema: O m\u00c3\u00a9todo `generateInvoice()` est\u00c3\u00a1 excessivamente longo, lidando com m\u00c3\u00baltiplas tarefas. Ele deveria ser refatorado em m\u00c3\u00a9todos menores, como `generateInvoiceNumber()`, `calculateTaxes()`, `applyDiscounts()`, etc."}
{"prompt": "class UserManager { public void registerUser(User user) { // Valida dados do usu\u00c3\u00a1rio // Cria registro no banco de dados // Envia e-mail de boas-vindas // Cria sess\u00c3\u00a3o do usu\u00c3\u00a1rio // Loga a a\u00c3\u00a7\u00c3\u00a3o } }", "completion": "Problema: O m\u00c3\u00a9todo `registerUser()` faz muitas coisas diferentes. Esse Long Method deveria ser dividido em m\u00c3\u00a9todos menores e mais focados, como `validateUserData()`, `createUserRecord()`, `sendWelcomeEmail()`, etc."}
{"prompt": "class PaymentService { public void processPayment(Payment payment) { // Valida detalhes do pagamento // Verifica saldo do cliente // Processa a transa\u00c3\u00a7\u00c3\u00a3o // Envia notifica\u00c3\u00a7\u00c3\u00a3o de pagamento } }", "completion": "Problema: O m\u00c3\u00a9todo `processPayment()` est\u00c3\u00a1 realizando v\u00c3\u00a1rias tarefas e se tornou um Long Method. Deveria ser refatorado em m\u00c3\u00a9todos menores, como `validatePaymentDetails()`, `checkCustomerBalance()`, `processTransaction()`, etc."}
{"prompt": "class ReservationSystem { public void bookRoom(Reservation reservation) { // Verifica disponibilidade // Calcula o pre\u00c3\u00a7o total // Reserva o quarto // Envia confirma\u00c3\u00a7\u00c3\u00a3o ao cliente } }", "completion": "Problema: O m\u00c3\u00a9todo `bookRoom()` \u00c3\u00a9 um Long Method que lida com v\u00c3\u00a1rias responsabilidades. Ele deveria ser dividido em m\u00c3\u00a9todos menores, como `checkAvailability()`, `calculateTotalPrice()`, `reserveRoom()`, etc."}
{"prompt": "class DataProcessor { public void processData(List<Data> dataList) { // Valida dados // Normaliza os dados // Aplica transforma\u00c3\u00a7\u00c3\u00b5es // Gera relat\u00c3\u00b3rios // Armazena no banco de dados } }", "completion": "Problema: O m\u00c3\u00a9todo `processData()` est\u00c3\u00a1 excessivamente longo e realizando muitas tarefas. Ele deveria ser dividido em m\u00c3\u00a9todos menores, como `validateData()`, `normalizeData()`, `applyTransformations()`, etc."}
{"prompt": "class CustomerService { public void handleCustomerRequest(CustomerRequest request) { // Valida a solicita\u00c3\u00a7\u00c3\u00a3o // Autentica o cliente // Processa a solicita\u00c3\u00a7\u00c3\u00a3o // Envia resposta ao cliente // Loga a solicita\u00c3\u00a7\u00c3\u00a3o } }", "completion": "Problema: O m\u00c3\u00a9todo `handleCustomerRequest()` \u00c3\u00a9 um Long Method que realiza m\u00c3\u00baltiplas responsabilidades. Ele deveria ser refatorado em m\u00c3\u00a9todos menores, como `validateRequest()`, `authenticateCustomer()`, `processRequest()`, etc."}
{"prompt": "class FileUploader { public void uploadFile(File file) { // Valida o arquivo // Gera metadados // Faz upload para o servidor // Atualiza banco de dados // Envia notifica\u00c3\u00a7\u00c3\u00a3o de sucesso } }", "completion": "Problema: O m\u00c3\u00a9todo `uploadFile()` est\u00c3\u00a1 fazendo muitas tarefas diferentes. Esse Long Method deveria ser refatorado em m\u00c3\u00a9todos menores e mais coesos, como `validateFile()`, `generateMetadata()`, `uploadToServer()`, etc."}
{"prompt": "class OrderProcessor { public void processOrder(String productId, int quantity, double price, String customerName, String customerAddress, String paymentMethod, String shippingMethod) { /* l\u00c3\u00b3gica de processamento */ } }", "completion": "Problema: O m\u00c3\u00a9todo `processOrder()` tem uma Long Parameter List com muitos par\u00c3\u00a2metros. Isso pode ser refatorado encapsulando os par\u00c3\u00a2metros em classes como `Order`, `Customer`, e `PaymentDetails`."}
{"prompt": "class ReportGenerator { public void generateReport(String title, String author, String content, int pageCount, String dateCreated, String format) { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de relat\u00c3\u00b3rio */ } }", "completion": "Problema: `generateReport()` tem uma Long Parameter List com muitos par\u00c3\u00a2metros. Esses par\u00c3\u00a2metros poderiam ser encapsulados em uma classe `Report` que contenha todos os dados necess\u00c3\u00a1rios para a gera\u00c3\u00a7\u00c3\u00a3o do relat\u00c3\u00b3rio."}
{"prompt": "class EmailService { public void sendEmail(String to, String from, String subject, String body, String cc, String bcc, String attachmentPath) { /* l\u00c3\u00b3gica de envio de e-mail */ } }", "completion": "Problema: O m\u00c3\u00a9todo `sendEmail()` possui muitos par\u00c3\u00a2metros. Refatorar esses par\u00c3\u00a2metros para uma classe `EmailMessage` ou utilizar o padr\u00c3\u00a3o *Builder* simplificaria a chamada do m\u00c3\u00a9todo."}
{"prompt": "class PaymentProcessor { public void processPayment(String cardNumber, String cardHolder, String expirationDate, String cvv, double amount, String currency, String paymentGateway) { /* l\u00c3\u00b3gica de processamento de pagamento */ } }", "completion": "Problema: O m\u00c3\u00a9todo `processPayment()` tem uma Long Parameter List. Par\u00c3\u00a2metros relacionados ao cart\u00c3\u00a3o de cr\u00c3\u00a9dito e pagamento podem ser encapsulados em classes como `CreditCard` e `PaymentDetails`."}
{"prompt": "class FlightBookingService { public void bookFlight(String departureCity, String destinationCity, String flightDate, String returnDate, String passengerName, String passengerEmail, String seatPreference) { /* l\u00c3\u00b3gica de reserva de voo */ } }", "completion": "Problema: O m\u00c3\u00a9todo `bookFlight()` tem muitos par\u00c3\u00a2metros. Esses par\u00c3\u00a2metros podem ser encapsulados em classes como `FlightDetails` e `Passenger` para simplificar o m\u00c3\u00a9todo."}
{"prompt": "class UserRegistrationService { public void registerUser(String firstName, String lastName, String email, String password, String address, String phoneNumber, String birthDate) { /* l\u00c3\u00b3gica de registro de usu\u00c3\u00a1rio */ } }", "completion": "Problema: O m\u00c3\u00a9todo `registerUser()` possui uma Long Parameter List. Esses par\u00c3\u00a2metros poderiam ser agrupados em uma classe `User` ou `UserProfile` para melhorar a coes\u00c3\u00a3o e facilitar o uso."}
{"prompt": "class ProductManager { public void addProduct(String productName, String productCode, String description, double price, String category, String supplierName, String supplierContact) { /* l\u00c3\u00b3gica de adi\u00c3\u00a7\u00c3\u00a3o de produto */ } }", "completion": "Problema: O m\u00c3\u00a9todo `addProduct()` tem muitos par\u00c3\u00a2metros. Esses dados podem ser encapsulados em classes como `Product` e `Supplier`, reduzindo a quantidade de par\u00c3\u00a2metros no m\u00c3\u00a9todo."}
{"prompt": "class InvoiceService { public void generateInvoice(String invoiceNumber, String customerName, String customerAddress, double totalAmount, double taxAmount, String paymentMethod, String dueDate) { /* l\u00c3\u00b3gica de gera\u00c3\u00a7\u00c3\u00a3o de fatura */ } }", "completion": "Problema: `generateInvoice()` possui uma Long Parameter List. Esses par\u00c3\u00a2metros poderiam ser encapsulados em classes como `Invoice` e `Customer`, tornando o m\u00c3\u00a9todo mais simples."}
{"prompt": "class ReservationSystem { public void makeReservation(String guestName, String guestEmail, String checkInDate, String checkOutDate, String roomType, int roomNumber, String paymentMethod) { /* l\u00c3\u00b3gica de reserva */ } }", "completion": "Problema: O m\u00c3\u00a9todo `makeReservation()` tem muitos par\u00c3\u00a2metros. Esses dados poderiam ser encapsulados em classes como `Reservation` e `Guest` para reduzir a lista de par\u00c3\u00a2metros."}
{"prompt": "class ShoppingCartService { public void checkout(String cartId, String customerId, String paymentMethod, String shippingAddress, String billingAddress, String couponCode, double totalAmount) { /* l\u00c3\u00b3gica de finaliza\u00c3\u00a7\u00c3\u00a3o de compra */ } }", "completion": "Problema: O m\u00c3\u00a9todo `checkout()` tem uma Long Parameter List. Par\u00c3\u00a2metros relacionados ao pagamento, envio e cliente poderiam ser encapsulados em classes como `Cart`, `Customer`, e `PaymentDetails`."}
{"prompt": "class OrderProcessor { public void processOrder(Order order) { order.getCustomer().getAddress().getZipCode(); } }", "completion": "Problema: `processOrder()` usa uma cadeia de mensagens (`order.getCustomer().getAddress().getZipCode()`). Isso \u00c3\u00a9 um exemplo de Message Chains. O m\u00c3\u00a9todo `getZipCode()` poderia ser movido diretamente para `Order` ou `Customer` para evitar a cadeia."}
{"prompt": "class FlightBooking { public void bookFlight(Reservation reservation) { reservation.getFlight().getAirline().getTicketingSystem().reserveSeat(); } }", "completion": "Problema: O m\u00c3\u00a9todo `bookFlight()` usa uma cadeia de mensagens longa. Essa l\u00c3\u00b3gica de reserva de assento poderia ser encapsulada em um m\u00c3\u00a9todo `reserveSeat()` diretamente na classe `Reservation` para eliminar a cadeia."}
{"prompt": "class InvoiceService { public void generateInvoice(Invoice invoice) { invoice.getOrder().getCustomer().getBillingDetails().getCreditCard().charge(); } }", "completion": "Problema: `generateInvoice()` apresenta uma cadeia de chamadas longa. Isso pode ser refatorado, encapsulando a l\u00c3\u00b3gica de cobran\u00c3\u00a7a em um m\u00c3\u00a9todo `chargeCustomer()` dentro da classe `Invoice`."}
{"prompt": "class CarService { public void checkCarStatus(Car car) { car.getEngine().getFuelSystem().getFuelLevel(); } }", "completion": "Problema: O m\u00c3\u00a9todo `checkCarStatus()` usa uma cadeia de mensagens para acessar o n\u00c3\u00advel de combust\u00c3\u00advel. Essa cadeia pode ser encapsulada, fornecendo um m\u00c3\u00a9todo direto como `getFuelLevel()` na classe `Car`."}
{"prompt": "class EcommerceService { public void processOrder(Order order) { order.getCart().getCustomer().getPaymentInfo().getCreditCard().processPayment(); } }", "completion": "Problema: O m\u00c3\u00a9todo `processOrder()` apresenta uma cadeia de chamadas que poderia ser encapsulada em m\u00c3\u00a9todos como `processCustomerPayment()` diretamente em `Order` ou `Cart`, evitando o acoplamento."}
{"prompt": "class LibrarySystem { public void borrowBook(Borrower borrower) { borrower.getLibraryCard().getLibrary().getCatalog().findBook(); } }", "completion": "Problema: `borrowBook()` cont\u00c3\u00a9m uma cadeia de mensagens que poderia ser reduzida. A l\u00c3\u00b3gica de encontrar o livro poderia ser movida para a classe `Borrower` ou `LibraryCard` para evitar a cadeia."}
{"prompt": "class EmployeeManager { public void promoteEmployee(Employee employee) { employee.getDepartment().getManager().approvePromotion(); } }", "completion": "Problema: A cadeia de chamadas `employee.getDepartment().getManager().approvePromotion()` pode ser encapsulada em um m\u00c3\u00a9todo `approvePromotion()` diretamente na classe `Employee` ou `Department`."}
{"prompt": "class BankService { public void transferMoney(Account fromAccount, Account toAccount) { fromAccount.getBank().getBranch().getManager().approveTransfer(); } }", "completion": "Problema: O m\u00c3\u00a9todo `transferMoney()` usa uma cadeia de mensagens que poderia ser eliminada. A l\u00c3\u00b3gica de aprova\u00c3\u00a7\u00c3\u00a3o de transfer\u00c3\u00aancia poderia ser encapsulada diretamente em `Account` ou `Bank`."}
{"prompt": "class ShoppingCartService { public void checkout(ShoppingCart cart) { cart.getCustomer().getShippingInfo().getShippingAddress().validate(); } }", "completion": "Problema: `checkout()` cont\u00c3\u00a9m uma cadeia de mensagens que pode ser evitada. A valida\u00c3\u00a7\u00c3\u00a3o do endere\u00c3\u00a7o poderia ser movida para `ShoppingCart` ou `Customer` para encapsular essa l\u00c3\u00b3gica."}
{"prompt": "class ReservationSystem { public void confirmReservation(Reservation reservation) { reservation.getHotel().getManager().getBookingSystem().confirm(); } }", "completion": "Problema: A cadeia de chamadas `reservation.getHotel().getManager().getBookingSystem().confirm()` pode ser encapsulada em um m\u00c3\u00a9todo como `confirm()` diretamente na classe `Reservation` ou `Hotel`."}
{"prompt": "class CustomerService { private CustomerRepository customerRepository; public Customer getCustomerById(int id) { return customerRepository.findCustomerById(id); } }", "completion": "Problema: `CustomerService` \u00c3\u00a9 uma classe Middle Man, pois sua \u00c3\u00banica fun\u00c3\u00a7\u00c3\u00a3o \u00c3\u00a9 delegar chamadas para `CustomerRepository`. O c\u00c3\u00b3digo poderia interagir diretamente com `CustomerRepository`, eliminando a necessidade de `CustomerService`."}
{"prompt": "class OrderManager { private OrderRepository orderRepository; public void saveOrder(Order order) { orderRepository.save(order); } public Order getOrderById(int id) { return orderRepository.findById(id); } }", "completion": "Problema: A classe `OrderManager` serve apenas como intermedi\u00c3\u00a1ria para `OrderRepository`, tornando-a uma classe Middle Man. \u00c3\u2030 melhor interagir diretamente com `OrderRepository`, eliminando o `OrderManager`."}
{"prompt": "class PaymentService { private PaymentGateway paymentGateway; public void processPayment(double amount) { paymentGateway.process(amount); } }", "completion": "Problema: `PaymentService` \u00c3\u00a9 uma classe Middle Man que apenas repassa chamadas para `PaymentGateway`. Interagir diretamente com `PaymentGateway` eliminaria a necessidade de `PaymentService`."}
{"prompt": "class EmailService { private EmailClient emailClient; public void sendEmail(String to, String message) { emailClient.send(to, message); } }", "completion": "Problema: `EmailService` n\u00c3\u00a3o faz nada al\u00c3\u00a9m de repassar chamadas para `EmailClient`. Isso \u00c3\u00a9 um exemplo de Middle Man, e a solu\u00c3\u00a7\u00c3\u00a3o seria interagir diretamente com `EmailClient`, eliminando a classe intermedi\u00c3\u00a1ria."}
{"prompt": "class InventoryManager { private Inventory inventory; public int getStockLevel(Product product) { return inventory.getStockLevel(product); } }", "completion": "Problema: A classe `InventoryManager` \u00c3\u00a9 apenas uma intermedi\u00c3\u00a1ria que delega chamadas a `Inventory`. Esse \u00c3\u00a9 um caso claro de Middle Man, e a solu\u00c3\u00a7\u00c3\u00a3o seria eliminar `InventoryManager` e interagir diretamente com `Inventory`."}
{"prompt": "class AccountService { private AccountRepository accountRepository; public Account findAccountByNumber(String accountNumber) { return accountRepository.findByAccountNumber(accountNumber); } }", "completion": "Problema: `AccountService` \u00c3\u00a9 uma classe intermedi\u00c3\u00a1ria que apenas delega o trabalho a `AccountRepository`. \u00c3\u2030 um exemplo de Middle Man, e o c\u00c3\u00b3digo poderia interagir diretamente com `AccountRepository`."}
{"prompt": "class LoggerService { private Logger logger; public void logMessage(String message) { logger.log(message); } }", "completion": "Problema: `LoggerService` \u00c3\u00a9 uma classe Middle Man que apenas repassa mensagens para `Logger`. A classe intermedi\u00c3\u00a1ria poderia ser eliminada, interagindo diretamente com `Logger`."}
{"prompt": "class AuthenticationManager { private AuthService authService; public boolean authenticate(String username, String password) { return authService.authenticate(username, password); } }", "completion": "Problema: `AuthenticationManager` \u00c3\u00a9 uma classe intermedi\u00c3\u00a1ria que repassa chamadas para `AuthService`. Este \u00c3\u00a9 um caso de Middle Man, e o c\u00c3\u00b3digo poderia interagir diretamente com `AuthService`."}
{"prompt": "class FileStorageService { private FileSystem fileSystem; public void saveFile(String fileName, byte[] data) { fileSystem.writeFile(fileName, data); } }", "completion": "Problema: `FileStorageService` serve apenas como intermedi\u00c3\u00a1ria para o `FileSystem`, o que torna a classe redundante. O c\u00c3\u00b3digo poderia interagir diretamente com `FileSystem`, eliminando o Middle Man."}
{"prompt": "class UserNotificationService { private NotificationSender notificationSender; public void notifyUser(User user, String message) { notificationSender.sendNotification(user, message); } }", "completion": "Problema: A classe `UserNotificationService` n\u00c3\u00a3o faz nada al\u00c3\u00a9m de repassar a responsabilidade para `NotificationSender`, sendo uma Middle Man. Interagir diretamente com `NotificationSender` eliminaria a classe intermedi\u00c3\u00a1ria."}
{"prompt": "class Vehicle { } class Car extends Vehicle { } class Bike extends Vehicle { } class VehicleService { } class CarService extends VehicleService { } class BikeService extends VehicleService { }", "completion": "Problema: O code smell de Parallel Inheritance Hierarchies est\u00c3\u00a1 presente. Cada vez que uma nova classe `Vehicle` \u00c3\u00a9 adicionada, uma correspondente `VehicleService` tamb\u00c3\u00a9m deve ser criada, o que duplica o esfor\u00c3\u00a7o e torna o c\u00c3\u00b3digo mais dif\u00c3\u00adcil de manter. Considere unificar a l\u00c3\u00b3gica de servi\u00c3\u00a7o ou usar composi\u00c3\u00a7\u00c3\u00a3o para evitar paralelismo na hierarquia."}
{"prompt": "class Animal { } class Dog extends Animal { } class Cat extends Animal { } class AnimalTrainer { } class DogTrainer extends AnimalTrainer { } class CatTrainer extends AnimalTrainer { }", "completion": "Problema: A hierarquia de classes `Animal` e `AnimalTrainer` mostram Parallel Inheritance Hierarchies. Para cada novo `Animal`, h\u00c3\u00a1 uma nova classe `Trainer` correspondente. Isso cria duplica\u00c3\u00a7\u00c3\u00a3o desnecess\u00c3\u00a1ria e aumenta a complexidade. Considere usar uma abordagem mais gen\u00c3\u00a9rica para treinar diferentes animais."}
{"prompt": "class Product { } class Electronics extends Product { } class Food extends Product { } class ProductPricing { } class ElectronicsPricing extends ProductPricing { } class FoodPricing extends ProductPricing { }", "completion": "Problema: O code smell de Parallel Inheritance Hierarchies \u00c3\u00a9 evidente, pois a adi\u00c3\u00a7\u00c3\u00a3o de novos tipos de `Product` requer a cria\u00c3\u00a7\u00c3\u00a3o de uma classe correspondente em `ProductPricing`. Uma abordagem mais modular ou orientada a composi\u00c3\u00a7\u00c3\u00a3o pode resolver esse problema."}
{"prompt": "class Document { } class PDFDocument extends Document { } class WordDocument extends Document { } class DocumentConverter { } class PDFConverter extends DocumentConverter { } class WordConverter extends DocumentConverter { }", "completion": "Problema: O problema de Parallel Inheritance Hierarchies ocorre quando novas subclasses de `Document` requerem a cria\u00c3\u00a7\u00c3\u00a3o de novas subclasses correspondentes de `DocumentConverter`. Isso pode ser resolvido com estrat\u00c3\u00a9gias de convers\u00c3\u00a3o mais flex\u00c3\u00adveis ou uso de interfaces em vez de criar classes paralelas."}
{"prompt": "class Shape { } class Circle extends Shape { } class Square extends Shape { } class ShapeRenderer { } class CircleRenderer extends ShapeRenderer { } class SquareRenderer extends ShapeRenderer { }", "completion": "Problema: A hierarquia de classes `Shape` e `ShapeRenderer` demonstra Parallel Inheritance Hierarchies. Para cada novo `Shape`, h\u00c3\u00a1 uma classe `Renderer` correspondente. Considere uma abordagem gen\u00c3\u00a9rica para renderiza\u00c3\u00a7\u00c3\u00a3o de formas para evitar essa duplica\u00c3\u00a7\u00c3\u00a3o paralela."}
{"prompt": "class Account { } class SavingsAccount extends Account { } class CheckingAccount extends Account { } class AccountValidator { } class SavingsAccountValidator extends AccountValidator { } class CheckingAccountValidator extends AccountValidator { }", "completion": "Problema: O code smell de Parallel Inheritance Hierarchies est\u00c3\u00a1 presente aqui, pois cada novo tipo de `Account` exige a cria\u00c3\u00a7\u00c3\u00a3o de uma nova classe `Validator` correspondente. Considere usar estrat\u00c3\u00a9gias ou padr\u00c3\u00b5es como o Strategy para unificar a valida\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class Employee { } class Manager extends Employee { } class Developer extends Employee { } class EmployeeReport { } class ManagerReport extends EmployeeReport { } class DeveloperReport extends EmployeeReport { }", "completion": "Problema: As classes `Employee` e `EmployeeReport` sofrem de Parallel Inheritance Hierarchies, pois cada nova subclasse de `Employee` necessita de uma correspondente `Report`. Isso cria redund\u00c3\u00a2ncia e aumenta a manuten\u00c3\u00a7\u00c3\u00a3o. Considere uma abordagem gen\u00c3\u00a9rica para relat\u00c3\u00b3rios."}
{"prompt": "class PaymentMethod { } class CreditCard extends PaymentMethod { } class PayPal extends PaymentMethod { } class PaymentProcessor { } class CreditCardProcessor extends PaymentProcessor { } class PayPalProcessor extends PaymentProcessor { }", "completion": "Problema: O code smell de Parallel Inheritance Hierarchies aparece aqui porque cada novo tipo de `PaymentMethod` exige a cria\u00c3\u00a7\u00c3\u00a3o de um novo `PaymentProcessor` correspondente. Considere usar um design mais flex\u00c3\u00advel ou unificar o processamento de pagamento."}
{"prompt": "class Game { } class Football extends Game { } class Basketball extends Game { } class GameRules { } class FootballRules extends GameRules { } class BasketballRules extends GameRules { }", "completion": "Problema: O Parallel Inheritance Hierarchies \u00c3\u00a9 evidente, pois cada novo tipo de `Game` requer uma nova classe de `GameRules`. Isso pode ser melhorado usando uma abordagem mais flex\u00c3\u00advel, como configura\u00c3\u00a7\u00c3\u00a3o baseada em regras."}
{"prompt": "class Vehicle { } class Truck extends Vehicle { } class Motorcycle extends Vehicle { } class VehicleInsurance { } class TruckInsurance extends VehicleInsurance { } class MotorcycleInsurance extends VehicleInsurance { }", "completion": "Problema: Parallel Inheritance Hierarchies ocorre aqui, com cada novo tipo de `Vehicle` exigindo uma nova subclasse correspondente de `VehicleInsurance`. O uso de composi\u00c3\u00a7\u00c3\u00a3o ou estrat\u00c3\u00a9gias de seguro flex\u00c3\u00adveis pode ajudar a resolver essa duplica\u00c3\u00a7\u00c3\u00a3o desnecess\u00c3\u00a1ria."}
{"prompt": "class Address { private String street; private String city; private String zipCode; }", "completion": "Problema: `street`, `city`, e `zipCode` s\u00c3\u00a3o representados como `String`. Isso \u00c3\u00a9 um exemplo de Primitive Obsession. Uma classe `ZipCode` ou `Address` poderia encapsular esses valores, garantindo valida\u00c3\u00a7\u00c3\u00b5es e comportamentos mais adequados."}
{"prompt": "class Order { private String productId; private int quantity; private double price; }", "completion": "Problema: `productId`, `quantity`, e `price` est\u00c3\u00a3o sendo representados por tipos primitivos. Classes como `Product`, `Quantity`, e `Price` poderiam ser criadas para encapsular a l\u00c3\u00b3gica de manipula\u00c3\u00a7\u00c3\u00a3o e valida\u00c3\u00a7\u00c3\u00a3o desses valores."}
{"prompt": "class Payment { private String cardNumber; private String expirationDate; private String cvv; }", "completion": "Problema: `cardNumber`, `expirationDate`, e `cvv` s\u00c3\u00a3o representados como `String`. Criar classes como `CreditCard` ou `CardDetails` encapsularia esses dados de forma mais segura e expressiva."}
{"prompt": "class Person { private String firstName; private String lastName; private int age; }", "completion": "Problema: O uso de `String` para `firstName` e `lastName` e de `int` para `age` s\u00c3\u00a3o exemplos de Primitive Obsession. Classes como `Name` ou `Age` poderiam encapsular l\u00c3\u00b3gica de valida\u00c3\u00a7\u00c3\u00a3o e garantir consist\u00c3\u00aancia dos dados."}
{"prompt": "class TemperatureSensor { private double temperature; }", "completion": "Problema: O uso de `double` para representar `temperature` \u00c3\u00a9 um exemplo de Primitive Obsession. Uma classe `Temperature` poderia encapsular a unidade de medida (Celsius, Fahrenheit) e fornecer m\u00c3\u00a9todos para convers\u00c3\u00a3o e valida\u00c3\u00a7\u00c3\u00a3o."}
{"prompt": "class BankAccount { private String accountNumber; private double balance; }", "completion": "Problema: `accountNumber` e `balance` s\u00c3\u00a3o representados por `String` e `double`, respectivamente. Criar classes como `AccountNumber` e `Money` poderia encapsular valida\u00c3\u00a7\u00c3\u00b5es e l\u00c3\u00b3gica associada a esses valores."}
{"prompt": "class Invoice { private String invoiceNumber; private double totalAmount; }", "completion": "Problema: O uso de `String` para `invoiceNumber` e `double` para `totalAmount` s\u00c3\u00a3o exemplos de Primitive Obsession. Classes como `InvoiceNumber` e `Amount` poderiam ser usadas para encapsular a l\u00c3\u00b3gica de manipula\u00c3\u00a7\u00c3\u00a3o e valida\u00c3\u00a7\u00c3\u00a3o desses valores."}
{"prompt": "class Phone { private String countryCode; private String areaCode; private String number; }", "completion": "Problema: `countryCode`, `areaCode` e `number` s\u00c3\u00a3o todos representados por `String`. Uma classe `PhoneNumber` poderia encapsular a valida\u00c3\u00a7\u00c3\u00a3o e formata\u00c3\u00a7\u00c3\u00a3o correta desses valores."}
{"prompt": "class Event { private String startDate; private String endDate; }", "completion": "Problema: O uso de `String` para representar `startDate` e `endDate` \u00c3\u00a9 um exemplo de Primitive Obsession. Criar uma classe `DateRange` ou `EventDate` poderia encapsular a l\u00c3\u00b3gica de compara\u00c3\u00a7\u00c3\u00a3o, valida\u00c3\u00a7\u00c3\u00a3o e formata\u00c3\u00a7\u00c3\u00a3o das datas."}
{"prompt": "class ShoppingCart { private List<String> items; private double totalPrice; }", "completion": "Problema: O uso de `String` para representar `items` e `double` para `totalPrice` s\u00c3\u00a3o exemplos de Primitive Obsession. Uma classe `Item` e `Price` poderiam encapsular essas informa\u00c3\u00a7\u00c3\u00b5es e fornecer comportamentos espec\u00c3\u00adficos relacionados."}
{"prompt": "class Bird { public void fly() { System.out.println('Flying'); } } class Penguin extends Bird { @Override public void fly() { throw new UnsupportedOperationException('Penguins cannot fly'); } }", "completion": "Problema: `Penguin` herda o m\u00c3\u00a9todo `fly()` de `Bird`, mas n\u00c3\u00a3o pode voar. Isso \u00c3\u00a9 um exemplo de Refused Bequest. A heran\u00c3\u00a7a est\u00c3\u00a1 incorreta; `Penguin` n\u00c3\u00a3o deveria herdar de `Bird`. Uma poss\u00c3\u00advel solu\u00c3\u00a7\u00c3\u00a3o seria criar uma hierarquia diferente, como `FlightlessBird`."}
{"prompt": "class Employee { public void work() { System.out.println('Working'); } public void attendMeetings() { System.out.println('Attending meetings'); } } class Intern extends Employee { @Override public void attendMeetings() { throw new UnsupportedOperationException('Interns do not attend meetings'); } }", "completion": "Problema: `Intern` herda o m\u00c3\u00a9todo `attendMeetings()` de `Employee`, mas n\u00c3\u00a3o o utiliza. Isso \u00c3\u00a9 Refused Bequest. A hierarquia est\u00c3\u00a1 incorreta, e talvez seja necess\u00c3\u00a1rio repensar o design ou usar composi\u00c3\u00a7\u00c3\u00a3o ao inv\u00c3\u00a9s de heran\u00c3\u00a7a."}
{"prompt": "class Vehicle { public void drive() { System.out.println('Driving'); } } class Bicycle extends Vehicle { @Override public void drive() { throw new UnsupportedOperationException('Bicycles cannot be driven like cars'); } }", "completion": "Problema: `Bicycle` herda o m\u00c3\u00a9todo `drive()` de `Vehicle`, mas n\u00c3\u00a3o pode ser dirigido da mesma maneira que um carro. Isso \u00c3\u00a9 Refused Bequest. `Bicycle` n\u00c3\u00a3o deveria herdar de `Vehicle`; uma separa\u00c3\u00a7\u00c3\u00a3o de classes seria mais apropriada."}
{"prompt": "class Manager { public void manageTeam() { System.out.println('Managing team'); } public void approveBudget() { System.out.println('Approving budget'); } } class JuniorManager extends Manager { @Override public void approveBudget() { throw new UnsupportedOperationException('Junior Managers do not approve budgets'); } }", "completion": "Problema: `JuniorManager` herda o m\u00c3\u00a9todo `approveBudget()` de `Manager`, mas n\u00c3\u00a3o precisa dele. Isso \u00c3\u00a9 um exemplo de Refused Bequest. Talvez `JuniorManager` e `Manager` devam implementar uma interface comum em vez de usarem heran\u00c3\u00a7a."}
{"prompt": "class Appliance { public void turnOn() { System.out.println('Turning on'); } public void cook() { System.out.println('Cooking'); } } class WashingMachine extends Appliance { @Override public void cook() { throw new UnsupportedOperationException('Washing machines do not cook'); } }", "completion": "Problema: `WashingMachine` herda o m\u00c3\u00a9todo `cook()` de `Appliance`, mas n\u00c3\u00a3o pode cozinhar. Isso \u00c3\u00a9 Refused Bequest. A hierarquia est\u00c3\u00a1 errada, e `WashingMachine` n\u00c3\u00a3o deveria herdar de `Appliance`."}
{"prompt": "class Animal { public void makeSound() { System.out.println('Making sound'); } public void fly() { System.out.println('Flying'); } } class Dog extends Animal { @Override public void fly() { throw new UnsupportedOperationException('Dogs cannot fly'); } }", "completion": "Problema: `Dog` herda o m\u00c3\u00a9todo `fly()` de `Animal`, mas n\u00c3\u00a3o pode voar. Isso \u00c3\u00a9 Refused Bequest, indicando que a rela\u00c3\u00a7\u00c3\u00a3o de heran\u00c3\u00a7a est\u00c3\u00a1 incorreta. Uma solu\u00c3\u00a7\u00c3\u00a3o seria separar os animais voadores e terrestres em classes distintas."}
{"prompt": "class Database { public void connect() { System.out.println('Connecting to database'); } public void executeTransaction() { System.out.println('Executing transaction'); } } class ReadOnlyDatabase extends Database { @Override public void executeTransaction() { throw new UnsupportedOperationException('Read-only databases do not execute transactions'); } }", "completion": "Problema: `ReadOnlyDatabase` herda o m\u00c3\u00a9todo `executeTransaction()` de `Database`, mas n\u00c3\u00a3o o utiliza. Isso \u00c3\u00a9 Refused Bequest. O design deveria ser refatorado para que `ReadOnlyDatabase` n\u00c3\u00a3o herde funcionalidades desnecess\u00c3\u00a1rias."}
{"prompt": "class Vehicle { public void drive() { System.out.println('Driving'); } public void refuel() { System.out.println('Refueling'); } } class ElectricCar extends Vehicle { @Override public void refuel() { throw new UnsupportedOperationException('Electric cars do not refuel'); } }", "completion": "Problema: `ElectricCar` herda o m\u00c3\u00a9todo `refuel()` de `Vehicle`, mas n\u00c3\u00a3o precisa dele. Isso \u00c3\u00a9 Refused Bequest. O design deveria ser ajustado para que `ElectricCar` n\u00c3\u00a3o herde m\u00c3\u00a9todos que n\u00c3\u00a3o faz sentido usar."}
{"prompt": "class Account { public void withdraw() { System.out.println('Withdrawing money'); } public void transferFunds() { System.out.println('Transferring funds'); } } class SavingsAccount extends Account { @Override public void transferFunds() { throw new UnsupportedOperationException('Savings accounts cannot transfer funds'); } }", "completion": "Problema: `SavingsAccount` herda o m\u00c3\u00a9todo `transferFunds()` de `Account`, mas n\u00c3\u00a3o pode transferir fundos. Isso \u00c3\u00a9 Refused Bequest e sugere que a hierarquia est\u00c3\u00a1 incorreta. Talvez `SavingsAccount` deva ser separado de outras contas."}
{"prompt": "class Printer { public void print() { System.out.println('Printing document'); } public void fax() { System.out.println('Sending fax'); } } class BasicPrinter extends Printer { @Override public void fax() { throw new UnsupportedOperationException('Basic printers do not send faxes'); } }", "completion": "Problema: `BasicPrinter` herda o m\u00c3\u00a9todo `fax()` de `Printer`, mas n\u00c3\u00a3o precisa dele. Isso \u00c3\u00a9 Refused Bequest. Uma refatora\u00c3\u00a7\u00c3\u00a3o para remover funcionalidades desnecess\u00c3\u00a1rias em subclasses resolveria o problema."}
{"prompt": "class User { public void updateUserName(String newName) { this.name = newName; updateUserInDatabase(); logUpdate(); notifyAdmin(); } } class Logger { public void logUpdate() { /* l\u00c3\u00b3gica de registro */ } } class AdminNotifier { public void notifyAdmin() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o */ } } class Database { public void updateUserInDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Ao alterar o nome de um usu\u00c3\u00a1rio, voc\u00c3\u00aa precisa modificar a l\u00c3\u00b3gica em v\u00c3\u00a1rias classes (`User`, `Logger`, `AdminNotifier`, `Database`). Isso caracteriza Shotgun Surgery. Essas responsabilidades relacionadas deveriam ser centralizadas para reduzir a dispers\u00c3\u00a3o das mudan\u00c3\u00a7as."}
{"prompt": "class Employee { public void updateEmployeeRecord() { updateDatabase(); sendUpdateEmail(); updateHRSystem(); } } class EmailService { public void sendUpdateEmail() { /* l\u00c3\u00b3gica de envio de e-mail */ } } class HRSystem { public void updateHRSystem() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o do sistema de RH */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Ao atualizar um registro de funcion\u00c3\u00a1rio, \u00c3\u00a9 necess\u00c3\u00a1rio modificar a l\u00c3\u00b3gica em v\u00c3\u00a1rias classes. Isso \u00c3\u00a9 Shotgun Surgery. A l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de registro deveria ser centralizada, como em um `EmployeeService`, para evitar a necessidade de altera\u00c3\u00a7\u00c3\u00b5es espalhadas."}
{"prompt": "class Order { public void cancelOrder() { cancelDatabaseEntry(); refundPayment(); notifyCustomer(); updateInventory(); } } class PaymentProcessor { public void refundPayment() { /* l\u00c3\u00b3gica de reembolso */ } } class InventorySystem { public void updateInventory() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o de estoque */ } } class CustomerNotifier { public void notifyCustomer() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao cliente */ } } class Database { public void cancelDatabaseEntry() { /* l\u00c3\u00b3gica de cancelamento no banco de dados */ } }", "completion": "Problema: O cancelamento de um pedido exige mudan\u00c3\u00a7as em v\u00c3\u00a1rias classes, caracterizando Shotgun Surgery. A l\u00c3\u00b3gica de cancelamento deveria estar encapsulada em uma classe como `OrderService` para evitar a dispers\u00c3\u00a3o da funcionalidade."}
{"prompt": "class Vehicle { public void performMaintenance() { updateServiceLog(); notifyOwner(); orderReplacementParts(); } } class ServiceLogger { public void updateServiceLog() { /* l\u00c3\u00b3gica de registro de servi\u00c3\u00a7o */ } } class OwnerNotifier { public void notifyOwner() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao dono */ } } class PartsOrderSystem { public void orderReplacementParts() { /* l\u00c3\u00b3gica de pedido de pe\u00c3\u00a7as */ } }", "completion": "Problema: Realizar a manuten\u00c3\u00a7\u00c3\u00a3o de um ve\u00c3\u00adculo requer altera\u00c3\u00a7\u00c3\u00b5es em v\u00c3\u00a1rias classes, caracterizando Shotgun Surgery. A manuten\u00c3\u00a7\u00c3\u00a3o deveria ser tratada em uma classe centralizada, como `MaintenanceService`, para reduzir a propaga\u00c3\u00a7\u00c3\u00a3o de mudan\u00c3\u00a7as."}
{"prompt": "class Booking { public void updateBooking() { updateDatabase(); notifyGuest(); sendInvoice(); } } class GuestNotifier { public void notifyGuest() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao h\u00c3\u00b3spede */ } } class InvoiceService { public void sendInvoice() { /* l\u00c3\u00b3gica de envio de fatura */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Atualizar uma reserva envolve mudan\u00c3\u00a7as em v\u00c3\u00a1rias classes, caracterizando Shotgun Surgery. A l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o deveria ser centralizada, como em uma classe `BookingService`, para evitar a necessidade de altera\u00c3\u00a7\u00c3\u00b5es espalhadas."}
{"prompt": "class Product { public void updateProductDetails() { updateDatabase(); notifySuppliers(); updateWebsite(); } } class SupplierNotifier { public void notifySuppliers() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o aos fornecedores */ } } class WebsiteUpdater { public void updateWebsite() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o do site */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Atualizar os detalhes de um produto exige mudan\u00c3\u00a7as em v\u00c3\u00a1rias classes, o que caracteriza Shotgun Surgery. Essa funcionalidade deveria ser centralizada em uma classe como `ProductService`."}
{"prompt": "class Account { public void deactivateAccount() { updateDatabase(); disableAccess(); notifyUser(); updateBilling(); } } class AccessManager { public void disableAccess() { /* l\u00c3\u00b3gica de desativa\u00c3\u00a7\u00c3\u00a3o de acesso */ } } class UserNotifier { public void notifyUser() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao usu\u00c3\u00a1rio */ } } class BillingSystem { public void updateBilling() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o do sistema de faturamento */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: A desativa\u00c3\u00a7\u00c3\u00a3o de uma conta envolve mudan\u00c3\u00a7as em v\u00c3\u00a1rias classes, o que caracteriza Shotgun Surgery. A desativa\u00c3\u00a7\u00c3\u00a3o deveria ser centralizada em uma classe como `AccountService` para evitar a dispers\u00c3\u00a3o da l\u00c3\u00b3gica."}
{"prompt": "class Project { public void closeProject() { archiveDocuments(); updateDatabase(); notifyTeam(); updateBilling(); } } class DocumentArchiver { public void archiveDocuments() { /* l\u00c3\u00b3gica de arquivamento de documentos */ } } class TeamNotifier { public void notifyTeam() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o \u00c3\u00a0 equipe */ } } class BillingSystem { public void updateBilling() { /* l\u00c3\u00b3gica de faturamento */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Fechar um projeto exige modifica\u00c3\u00a7\u00c3\u00b5es em v\u00c3\u00a1rias classes, o que caracteriza Shotgun Surgery. A l\u00c3\u00b3gica de fechamento de projetos deveria ser centralizada em uma classe como `ProjectService`."}
{"prompt": "class Customer { public void updateCustomerDetails() { updateDatabase(); notifyCRM(); updateLoyaltyProgram(); sendConfirmationEmail(); } } class CRMNotifier { public void notifyCRM() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao CRM */ } } class LoyaltyProgram { public void updateLoyaltyProgram() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o do programa de fidelidade */ } } class EmailService { public void sendConfirmationEmail() { /* l\u00c3\u00b3gica de envio de e-mail */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Atualizar os detalhes de um cliente envolve mudan\u00c3\u00a7as em v\u00c3\u00a1rias classes, caracterizando Shotgun Surgery. A l\u00c3\u00b3gica deveria ser centralizada em uma classe como `CustomerService`."}
{"prompt": "class Subscription { public void renewSubscription() { updateDatabase(); chargeCustomer(); notifyUser(); updateBillingSystem(); } } class PaymentProcessor { public void chargeCustomer() { /* l\u00c3\u00b3gica de cobran\u00c3\u00a7a */ } } class UserNotifier { public void notifyUser() { /* l\u00c3\u00b3gica de notifica\u00c3\u00a7\u00c3\u00a3o ao usu\u00c3\u00a1rio */ } } class BillingSystem { public void updateBillingSystem() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o do sistema de faturamento */ } } class Database { public void updateDatabase() { /* l\u00c3\u00b3gica de atualiza\u00c3\u00a7\u00c3\u00a3o no banco de dados */ } }", "completion": "Problema: Renovar uma assinatura envolve modifica\u00c3\u00a7\u00c3\u00b5es em v\u00c3\u00a1rias classes, caracterizando Shotgun Surgery. A l\u00c3\u00b3gica de renova\u00c3\u00a7\u00c3\u00a3o deveria ser centralizada em uma classe como `SubscriptionService`."}
{"prompt": "class Vehicle<T> { public T move(T movementType) { /* L\u00c3\u00b3gica de movimenta\u00c3\u00a7\u00c3\u00a3o gen\u00c3\u00a9rica */ return movementType; } }", "completion": "Problema: A classe `Vehicle` usa o tipo gen\u00c3\u00a9rico `T` para algo que provavelmente n\u00c3\u00a3o precisa ser gen\u00c3\u00a9rico, como o tipo de movimenta\u00c3\u00a7\u00c3\u00a3o. Isso \u00c3\u00a9 uma generalidade especulativa, j\u00c3\u00a1 que n\u00c3\u00a3o h\u00c3\u00a1 necessidade imediata de suportar m\u00c3\u00baltiplos tipos de movimenta\u00c3\u00a7\u00c3\u00a3o. Uma abordagem espec\u00c3\u00adfica seria mais simples e direta."}
{"prompt": "interface IOperation<T> { void execute(T data); } class PrintOperation implements IOperation<String> { public void execute(String data) { System.out.println(data); } }", "completion": "Problema: A interface `IOperation<T>` foi generalizada de maneira especulativa. Neste caso, `PrintOperation` s\u00c3\u00b3 lida com `String`, e n\u00c3\u00a3o h\u00c3\u00a1 necessidade de uma generaliza\u00c3\u00a7\u00c3\u00a3o t\u00c3\u00a3o ampla. O design poderia ser simplificado removendo a generalidade desnecess\u00c3\u00a1ria."}
{"prompt": "class ShapeFactory<T> { public T createShape() { // l\u00c3\u00b3gica de cria\u00c3\u00a7\u00c3\u00a3o gen\u00c3\u00a9rica return null; } }", "completion": "Problema: A classe `ShapeFactory` est\u00c3\u00a1 utilizando generics de maneira especulativa, sem uma necessidade clara de suportar diferentes tipos de formas. Isso adiciona complexidade desnecess\u00c3\u00a1ria ao c\u00c3\u00b3digo. Um design mais simples espec\u00c3\u00adfico para tipos de forma seria mais apropriado."}
{"prompt": "interface IDataProcessor<T> { void process(T data); } class StringDataProcessor implements IDataProcessor<String> { public void process(String data) { /* L\u00c3\u00b3gica de processamento de strings */ } }", "completion": "Problema: A interface `IDataProcessor<T>` foi generalizada sem um motivo claro. Neste contexto, o processador s\u00c3\u00b3 lida com `String`, tornando a generalidade desnecess\u00c3\u00a1ria e especulativa. O design poderia ser simplificado focando em tipos espec\u00c3\u00adficos."}
{"prompt": "abstract class AbstractManager { public abstract void manage(String resource); } class ResourceManager extends AbstractManager { @Override public void manage(String resource) { /* L\u00c3\u00b3gica de gerenciamento */ } }", "completion": "Problema: A classe `AbstractManager` foi introduzida sem nenhuma outra implementa\u00c3\u00a7\u00c3\u00a3o ou necessidade de abstra\u00c3\u00a7\u00c3\u00a3o adicional. Isso \u00c3\u00a9 uma generalidade especulativa e introduz uma camada extra de complexidade desnecess\u00c3\u00a1ria. Remover a classe abstrata simplificaria o design."}
{"prompt": "class PaymentStrategy { public void pay(String method) { /* l\u00c3\u00b3gica de pagamento gen\u00c3\u00a9rica */ } }", "completion": "Problema: A classe `PaymentStrategy` foi criada com a inten\u00c3\u00a7\u00c3\u00a3o de suportar m\u00c3\u00baltiplas estrat\u00c3\u00a9gias de pagamento, mas no momento s\u00c3\u00b3 implementa um \u00c3\u00banico m\u00c3\u00a9todo gen\u00c3\u00a9rico. Essa generalidade especulativa poderia ser simplificada at\u00c3\u00a9 que realmente existam m\u00c3\u00baltiplas estrat\u00c3\u00a9gias a serem suportadas."}
{"prompt": "class DataExporter<T> { public void export(T data) { /* Exporta\u00c3\u00a7\u00c3\u00a3o gen\u00c3\u00a9rica */ } }", "completion": "Problema: A classe `DataExporter<T>` usa generics de forma especulativa, sem uma necessidade real de lidar com diferentes tipos de dados. O design seria mais simples e mais f\u00c3\u00a1cil de manter se focasse em tipos de dados espec\u00c3\u00adficos."}
{"prompt": "class Command<T> { public void execute(T commandData) { /* L\u00c3\u00b3gica gen\u00c3\u00a9rica para comandos */ } }", "completion": "Problema: A classe `Command<T>` introduz generalidade de forma especulativa, sem que haja uma necessidade real de suportar diferentes tipos de dados de comando. O design poderia ser simplificado at\u00c3\u00a9 que m\u00c3\u00baltiplos tipos de comando sejam realmente necess\u00c3\u00a1rios."}
{"prompt": "interface IRepository<T> { T findById(int id); void save(T entity); } class UserRepository implements IRepository<User> { public User findById(int id) { return null; } public void save(User entity) { /* l\u00c3\u00b3gica de salvamento */ } }", "completion": "Problema: A interface `IRepository<T>` \u00c3\u00a9 uma abstra\u00c3\u00a7\u00c3\u00a3o excessivamente gen\u00c3\u00a9rica, especulando sobre a necessidade de um reposit\u00c3\u00b3rio para m\u00c3\u00baltiplos tipos. No momento, apenas um reposit\u00c3\u00b3rio de `User` existe. O design poderia ser simplificado at\u00c3\u00a9 que mais reposit\u00c3\u00b3rios sejam necess\u00c3\u00a1rios."}
{"prompt": "class Logger<T> { public void log(T message) { /* L\u00c3\u00b3gica de log gen\u00c3\u00a9rica */ } }", "completion": "Problema: A classe `Logger<T>` introduz generalidade de maneira especulativa, sem necessidade de suportar m\u00c3\u00baltiplos tipos de mensagens. O design seria mais claro e simples se focasse em tipos espec\u00c3\u00adficos, como `String`, at\u00c3\u00a9 que houvesse necessidade de outros tipos."}
{"prompt": "class PaymentProcessor { public void processPayment(String method) { switch (method) { case 'creditCard': processCreditCard(); break; case 'paypal': processPaypal(); break; default: throw new IllegalArgumentException('Invalid payment method'); } } }", "completion": "Problema: O `switch` baseado no m\u00c3\u00a9todo de pagamento indica um code smell. O polimorfismo pode ser usado, onde `CreditCardPayment` e `PaypalPayment` implementam uma interface `PaymentMethod`, eliminando a necessidade do `switch`."}
{"prompt": "class ShapeDrawer { public void drawShape(String shapeType) { switch (shapeType) { case 'circle': drawCircle(); break; case 'square': drawSquare(); break; default: throw new IllegalArgumentException('Unknown shape type'); } } }", "completion": "Problema: O uso do `switch` para decidir qual forma desenhar \u00c3\u00a9 um code smell. Isso pode ser substitu\u00c3\u00addo por polimorfismo, onde `Circle` e `Square` implementam uma interface `Shape` com um m\u00c3\u00a9todo `draw()`."}
{"prompt": "class NotificationSender { public void sendNotification(String type) { switch (type) { case 'email': sendEmail(); break; case 'sms': sendSms(); break; default: throw new IllegalArgumentException('Unknown notification type'); } } }", "completion": "Problema: O `switch` para decidir o tipo de notifica\u00c3\u00a7\u00c3\u00a3o a ser enviada \u00c3\u00a9 um code smell. Interfaces como `Notification` poderiam ser criadas com implementa\u00c3\u00a7\u00c3\u00b5es espec\u00c3\u00adficas, como `EmailNotification` e `SmsNotification`, eliminando a necessidade de `switch`."}
{"prompt": "class EmployeeManager { public void payEmployee(String employeeType) { switch (employeeType) { case 'fullTime': payFullTimeEmployee(); break; case 'partTime': payPartTimeEmployee(); break; default: throw new IllegalArgumentException('Unknown employee type'); } } }", "completion": "Problema: O `switch` com base no tipo de funcion\u00c3\u00a1rio \u00c3\u00a9 um code smell. O polimorfismo pode ser usado, onde `FullTimeEmployee` e `PartTimeEmployee` implementam uma interface `Employee` com um m\u00c3\u00a9todo `pay()`."}
{"prompt": "class DocumentPrinter { public void printDocument(String docType) { switch (docType) { case 'pdf': printPdf(); break; case 'word': printWord(); break; default: throw new IllegalArgumentException('Unknown document type'); } } }", "completion": "Problema: O uso do `switch` para decidir o tipo de documento a ser impresso \u00c3\u00a9 um code smell. Criar uma interface `Document` com implementa\u00c3\u00a7\u00c3\u00b5es como `PdfDocument` e `WordDocument` permitiria eliminar o `switch`."}
{"prompt": "class VehicleService { public void serviceVehicle(String vehicleType) { switch (vehicleType) { case 'car': serviceCar(); break; case 'motorcycle': serviceMotorcycle(); break; default: throw new IllegalArgumentException('Unknown vehicle type'); } } }", "completion": "Problema: O `switch` para decidir o tipo de ve\u00c3\u00adculo a ser reparado \u00c3\u00a9 um code smell. Classes como `Car` e `Motorcycle` poderiam implementar uma interface `Vehicle` com um m\u00c3\u00a9todo `service()`."}
{"prompt": "class OrderProcessor { public void processOrder(String orderType) { switch (orderType) { case 'online': processOnlineOrder(); break; case 'inStore': processInStoreOrder(); break; default: throw new IllegalArgumentException('Unknown order type'); } } }", "completion": "Problema: O uso do `switch` com base no tipo de pedido \u00c3\u00a9 um code smell. Interfaces como `Order` com implementa\u00c3\u00a7\u00c3\u00b5es espec\u00c3\u00adficas, como `OnlineOrder` e `InStoreOrder`, eliminariam a necessidade do `switch`."}
{"prompt": "class Game { public void playGame(String gameType) { switch (gameType) { case 'chess': playChess(); break; case 'checkers': playCheckers(); break; default: throw new IllegalArgumentException('Unknown game type'); } } }", "completion": "Problema: O `switch` para decidir qual jogo jogar \u00c3\u00a9 um code smell. Classes como `Chess` e `Checkers` poderiam implementar uma interface `Game` com um m\u00c3\u00a9todo `play()`."}
{"prompt": "class AnimalSound { public void makeSound(String animalType) { switch (animalType) { case 'dog': bark(); break; case 'cat': meow(); break; default: throw new IllegalArgumentException('Unknown animal type'); } } }", "completion": "Problema: O uso de `switch` para decidir o som que o animal faz \u00c3\u00a9 um code smell. Classes como `Dog` e `Cat` poderiam implementar uma interface `Animal` com um m\u00c3\u00a9todo `makeSound()`."}
{"prompt": "class ShippingCalculator { public double calculateShipping(String shippingMethod) { switch (shippingMethod) { case 'standard': return calculateStandardShipping(); case 'express': return calculateExpressShipping(); default: throw new IllegalArgumentException('Unknown shipping method'); } } }", "completion": "Problema: O `switch` baseado no m\u00c3\u00a9todo de envio \u00c3\u00a9 um code smell. Uma interface `ShippingMethod` com implementa\u00c3\u00a7\u00c3\u00b5es como `StandardShipping` e `ExpressShipping` eliminaria a necessidade de `switch`."}
{"prompt": "class Report { private String title; private String author; private String temporaryData; public void generateReport() { temporaryData = fetchData(); /* usa temporaryData */ } }", "completion": "Problema: `Report` tem um campo `temporaryData` que \u00c3\u00a9 usado apenas no m\u00c3\u00a9todo `generateReport()`. Isso \u00c3\u00a9 um exemplo de Temporary Field. `fetchData()` pode ser chamado diretamente dentro de `generateReport()` sem precisar de um campo tempor\u00c3\u00a1rio."}
{"prompt": "class CustomerOrder { private double discount; private double totalAmount; public void applyDiscount() { double temporaryDiscount = calculateDiscount(); discount = temporaryDiscount; } }", "completion": "Problema: `CustomerOrder` usa o campo `temporaryDiscount` apenas dentro do m\u00c3\u00a9todo `applyDiscount()`. Esse campo pode ser substitu\u00c3\u00addo por uma vari\u00c3\u00a1vel local em `applyDiscount()` para evitar o uso de campos tempor\u00c3\u00a1rios."}
{"prompt": "class Invoice { private double subtotal; private double tax; private double temporaryTotal; public void calculateTotal() { temporaryTotal = subtotal + tax; /* usa temporaryTotal */ } }", "completion": "Problema: `Invoice` possui um campo `temporaryTotal` que \u00c3\u00a9 usado apenas no m\u00c3\u00a9todo `calculateTotal()`. Esse campo pode ser substitu\u00c3\u00addo por uma vari\u00c3\u00a1vel local dentro de `calculateTotal()` para eliminar o campo tempor\u00c3\u00a1rio."}
{"prompt": "class UserProfile { private String firstName; private String lastName; private String temporaryAddress; public void updateAddress() { temporaryAddress = getNewAddress(); /* usa temporaryAddress */ } }", "completion": "Problema: `UserProfile` tem o campo `temporaryAddress` que \u00c3\u00a9 utilizado apenas no m\u00c3\u00a9todo `updateAddress()`. A fun\u00c3\u00a7\u00c3\u00a3o `getNewAddress()` pode ser chamada diretamente dentro de `updateAddress()` sem a necessidade de um campo tempor\u00c3\u00a1rio."}
{"prompt": "class TemperatureConverter { private double fahrenheit; private double celsius; private double temporaryResult; public void convert() { temporaryResult = (fahrenheit - 32) * 5 / 9; celsius = temporaryResult; } }", "completion": "Problema: `TemperatureConverter` usa o campo `temporaryResult` apenas no m\u00c3\u00a9todo `convert()`. Esse campo pode ser substitu\u00c3\u00addo por uma vari\u00c3\u00a1vel local dentro de `convert()` para evitar o uso de campos tempor\u00c3\u00a1rios."}
{"prompt": "class TaskScheduler { private Date startDate; private Date endDate; private Date temporaryDate; public void scheduleTask() { temporaryDate = calculateStartDate(); /* usa temporaryDate */ } }", "completion": "Problema: `TaskScheduler` possui o campo `temporaryDate` que \u00c3\u00a9 usado somente em `scheduleTask()`. A vari\u00c3\u00a1vel `temporaryDate` pode ser removida e o valor calculado pode ser usado diretamente no m\u00c3\u00a9todo."}
{"prompt": "class Employee { private double baseSalary; private double bonus; private double temporarySalary; public void calculateSalary() { temporarySalary = baseSalary + bonus; /* usa temporarySalary */ } }", "completion": "Problema: `Employee` tem o campo `temporarySalary` que \u00c3\u00a9 utilizado apenas no m\u00c3\u00a9todo `calculateSalary()`. Esse campo pode ser substitu\u00c3\u00addo por uma vari\u00c3\u00a1vel local dentro do m\u00c3\u00a9todo para eliminar o campo tempor\u00c3\u00a1rio."}
{"prompt": "class FileProcessor { private String fileName; private String temporaryData; public void processFile() { temporaryData = readFile(fileName); /* usa temporaryData */ } }", "completion": "Problema: `FileProcessor` usa o campo `temporaryData` apenas no m\u00c3\u00a9todo `processFile()`. A fun\u00c3\u00a7\u00c3\u00a3o `readFile(fileName)` pode ser chamada diretamente no m\u00c3\u00a9todo sem a necessidade de um campo tempor\u00c3\u00a1rio."}
{"prompt": "class Reservation { private Date checkInDate; private Date checkOutDate; private Date temporaryDate; public void extendReservation() { temporaryDate = calculateNewCheckOutDate(); /* usa temporaryDate */ } }", "completion": "Problema: `Reservation` tem o campo `temporaryDate` que \u00c3\u00a9 usado somente no m\u00c3\u00a9todo `extendReservation()`. Esse campo pode ser substitu\u00c3\u00addo por uma vari\u00c3\u00a1vel local dentro do m\u00c3\u00a9todo para evitar o uso de campos tempor\u00c3\u00a1rios."}
{"prompt": "class Recipe { private List<String> ingredients; private List<String> temporaryList; public void prepareDish() { temporaryList = new ArrayList<>(ingredients); /* usa temporaryList */ } }", "completion": "Problema: `Recipe` usa o campo `temporaryList` apenas no m\u00c3\u00a9todo `prepareDish()`. A lista tempor\u00c3\u00a1ria pode ser criada como uma vari\u00c3\u00a1vel local dentro do m\u00c3\u00a9todo, evitando a necessidade de um campo tempor\u00c3\u00a1rio."}
{"prompt": "class OrderProcessor { public void processOrder(Order order) { if (order.isPaid()) { // L\u00c3\u00b3gica de processamento } } }", "completion": "Problema: O `OrderProcessor` est\u00c3\u00a1 violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask ao verificar diretamente o estado de `Order` com `order.isPaid()`. Em vez disso, o m\u00c3\u00a9todo deveria dizer ao objeto `Order` para se processar, por exemplo, `order.processIfPaid()`."}
{"prompt": "class Car { public void start() { if (engine.isReady()) { engine.ignite(); } } }", "completion": "Problema: A classe `Car` est\u00c3\u00a1 violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask ao verificar o estado de `engine` com `engine.isReady()`. Em vez de perguntar ao motor se est\u00c3\u00a1 pronto, o m\u00c3\u00a9todo deveria ser algo como `engine.start()` e deixar que o motor se gerencie."}
{"prompt": "class EmployeeManager { public void promoteEmployee(Employee employee) { if (employee.getPerformanceRating() > 4) { employee.promote(); } } }", "completion": "Problema: `EmployeeManager` est\u00c3\u00a1 perguntando pela classifica\u00c3\u00a7\u00c3\u00a3o de desempenho (`getPerformanceRating()`) em vez de dizer ao objeto `Employee` o que fazer. Deveria ser algo como `employee.evaluateForPromotion()` para encapsular a l\u00c3\u00b3gica."}
{"prompt": "class AccountManager { public void closeAccount(Account account) { if (account.getBalance() == 0) { account.close(); } } }", "completion": "Problema: A classe `AccountManager` est\u00c3\u00a1 violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask ao perguntar sobre o saldo da conta antes de fech\u00c3\u00a1-la. Deveria dizer ao `Account` para tentar fechar-se, por exemplo, `account.closeIfBalanceZero()`."}
{"prompt": "class PaymentProcessor { public void processPayment(Payment payment) { if (payment.isValid()) { payment.execute(); } } }", "completion": "Problema: `PaymentProcessor` est\u00c3\u00a1 perguntando se o pagamento \u00c3\u00a9 v\u00c3\u00a1lido (`isValid()`) antes de process\u00c3\u00a1-lo, o que viola o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. Em vez disso, deveria dizer a `payment` para se processar, por exemplo, `payment.process()`."}
{"prompt": "class ShoppingCart { public void checkout() { if (cart.isEmpty()) { throw new RuntimeException('Cart is empty'); } cart.processPayment(); } }", "completion": "Problema: A classe `ShoppingCart` est\u00c3\u00a1 perguntando se o carrinho est\u00c3\u00a1 vazio antes de continuar (`cart.isEmpty()`), violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. Deveria dizer ao carrinho para se verificar e processar, como `cart.checkout()`."}
{"prompt": "class TemperatureController { public void controlTemperature(Room room) { if (room.getTemperature() < 18) { room.increaseHeat(); } } }", "completion": "Problema: `TemperatureController` est\u00c3\u00a1 perguntando pela temperatura do quarto antes de agir, violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. Deveria dizer ao `Room` para ajustar sua temperatura, por exemplo, `room.adjustTemperature()`."}
{"prompt": "class InvoiceService { public void processInvoice(Invoice invoice) { if (!invoice.isPaid()) { invoice.sendReminder(); } } }", "completion": "Problema: A classe `InvoiceService` est\u00c3\u00a1 verificando o estado de `Invoice` (`isPaid()`) antes de agir, o que viola o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. Em vez disso, deveria ser algo como `invoice.processPayment()` ou `invoice.handleUnpaid()`."}
{"prompt": "class DoorController { public void unlockDoor(Door door) { if (door.isLocked()) { door.unlock(); } } }", "completion": "Problema: `DoorController` est\u00c3\u00a1 perguntando se a porta est\u00c3\u00a1 trancada antes de destranc\u00c3\u00a1-la, violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. A l\u00c3\u00b3gica deveria ser encapsulada em `door.unlockIfNeeded()` ou simplesmente `door.unlock()`."}
{"prompt": "class UserNotifier { public void notifyUser(User user) { if (user.hasUnreadMessages()) { user.sendNotification(); } } }", "completion": "Problema: `UserNotifier` est\u00c3\u00a1 perguntando se o usu\u00c3\u00a1rio tem mensagens n\u00c3\u00a3o lidas antes de agir, violando o princ\u00c3\u00adpio Tell, Don\u00e2\u20ac\u2122t Ask. Deveria ser algo como `user.notifyIfNeeded()` ou `user.sendNotifications()`."}